<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ da28365)
 * Haxe source file: /usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx
 */

namespace sys\net;

use \sys\io\FileInput;
use \haxe\io\Output;
use \php\Boot;
use \php\_Boot\HxException;
use \haxe\io\Input;
use \php\_Boot\HxString;
use \php\_Boot\HxAnon;
use \sys\io\FileOutput;
use \haxe\io\Error;

/**
 * A TCP socket class : allow you to both connect to a given server and exchange messages or start your own server and wait for connections.
 */
class Socket {
	/**
	 * @var mixed
	 */
	public $__s;
	/**
	 * @var mixed
	 * A custom value that can be associated with the socket. Can be used to retrieve your custom infos after a `select`.
	 *
	 */
	public $custom;
	/**
	 * @var Input
	 * The stream on which you can read available data. By default the stream is blocking until the requested data is available,
	 * use `setBlocking(false)` or `setTimeout` to prevent infinite waiting.
	 */
	public $input;
	/**
	 * @var Output
	 * The stream on which you can send data. Please note that in case the output buffer you will block while writing the data, use `setBlocking(false)` or `setTimeout` to prevent that.
	 */
	public $output;
	/**
	 * @var string
	 */
	public $protocol;


	/**
	 * @param bool $r
	 * @param int $code
	 * @param string $msg
	 * 
	 * @return void
	 */
	static public function checkError ($r, $code, $msg) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:156: characters 3-24
		if ($r !== false) {
			#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:156: characters 18-24
			return;
		}
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:157: characters 3-8
		throw new HxException(Error::Custom("Error [" . ($code??'null') . "]: " . ($msg??'null')));
	}


	/**
	 * @param string $protocol
	 * 
	 * @return int
	 */
	static public function getProtocol ($protocol) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:165: characters 3-34
		return getprotobyname($protocol);
	}


	/**
	 * @param bool $isUdp
	 * 
	 * @return int
	 */
	static public function getType ($isUdp) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:161: characters 10-42
		if ($isUdp) {
			#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:161: characters 18-28
			return SOCK_DGRAM;
		} else {
			#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:161: characters 31-42
			return SOCK_STREAM;
		}
	}


	/**
	 * Wait until one of the sockets groups is ready for the given operation :
	 * - `read`contains sockets on which we want to wait for available data to be read,
	 * - `write` contains sockets on which we want to wait until we are allowed to write some data to their output buffers,
	 * - `others` contains sockets on which we want to wait for exceptional conditions.
	 * - `select` will block until one of the condition is met, in which case it will return the sockets for which the condition was true.
	 * In case a `timeout` (in seconds) is specified, select might wait at worse until the timeout expires.
	 * 
	 * @param \Array_hx $read
	 * @param \Array_hx $write
	 * @param \Array_hx $others
	 * @param float $timeout
	 * 
	 * @return object
	 */
	static public function select ($read, $write, $others, $timeout = null) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:170: characters 3-8
		throw new HxException("Not implemented");
	}


	/**
	 * Creates a new unconnected socket.
	 * 
	 * @return void
	 */
	public function __construct () {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:40: characters 3-53
		$this->input = new FileInput(null);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:41: characters 3-55
		$this->output = new FileOutput(null);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:42: characters 3-19
		$this->protocol = "tcp";
	}


	/**
	 * Accept a new connected client. This will return a connected socket on which you can read/write some data.
	 * 
	 * @return Socket
	 */
	public function accept () {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:106: characters 3-37
		$r = stream_socket_accept($this->__s);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:107: characters 3-61
		Socket::checkError($r, 0, "Unable to accept connections on socket");
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:108: characters 3-24
		$s = new Socket();
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:109: characters 3-12
		$s->__s = $r;
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:110: characters 3-20
		$s->assignHandler();
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:111: characters 3-11
		return $s;
	}


	/**
	 * @return void
	 */
	public function assignHandler () {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:46: characters 19-51
		$this->input->__f = $this->__s;
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:47: characters 19-53
		$this->output->__f = $this->__s;
	}


	/**
	 * Bind the socket to the given host/port so it can afterwards listen for connections there.
	 * 
	 * @param Host $host
	 * @param int $port
	 * 
	 * @return void
	 */
	public function bind ($host, $port) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:92: characters 3-31
		$errs = Boot::deref(null);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:93: characters 3-31
		$errn = Boot::deref(null);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:94: lines 94-99
		$r = stream_socket_server(($this->protocol??'null') . "://" . ($host->host??'null') . ":" . ($port??'null'), $errn, $errs, ($this->protocol === "udp" ? STREAM_SERVER_BIND : STREAM_SERVER_BIND | STREAM_SERVER_LISTEN));
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:100: characters 3-35
		Socket::checkError($r, $errn, $errs);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:101: characters 3-15
		$this->__s = $r;
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:102: characters 3-18
		$this->assignHandler();
	}


	/**
	 * Closes the socket : make sure to properly close all your sockets or you will crash when you run out of file descriptors.
	 * 
	 * @return void
	 */
	public function close () {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:51: characters 3-14
		fclose($this->__s);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:52: characters 19-52
		$this->input->__f = null;
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:53: characters 19-54
		$this->output->__f = null;
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:54: characters 3-16
		$this->input->close();
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:55: characters 3-17
		$this->output->close();
	}


	/**
	 * Connect to the given server host/port. Throw an exception in case we couldn't successfully connect.
	 * 
	 * @param Host $host
	 * @param int $port
	 * 
	 * @return void
	 */
	public function connect ($host, $port) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:69: characters 3-19
		$errs = null;
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:70: characters 3-19
		$errn = null;
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:71: characters 3-87
		$r = stream_socket_client(($this->protocol??'null') . "://" . ($host->host??'null') . ":" . ($port??'null'), $errn, $errs);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:72: characters 3-35
		Socket::checkError($r, $errn, $errs);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:73: characters 3-10
		$this->__s = $r;
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:74: characters 3-18
		$this->assignHandler();
	}


	/**
	 * Return the information about our side of a connected socket.
	 * 
	 * @return object
	 */
	public function host () {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:130: characters 3-46
		$r = stream_socket_get_name($this->__s, false);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:131: characters 3-55
		Socket::checkError($r, 0, "Unable to retrieve the host name");
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:132: characters 3-23
		return $this->hpOfString($r);
	}


	/**
	 * @param string $s
	 * 
	 * @return object
	 */
	public function hpOfString ($s) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:115: characters 3-28
		$parts = \Array_hx::wrap(explode(":", $s));
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:116: lines 116-120
		if ($parts->length === 2) {
			#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:117: characters 20-38
			$tmp = new Host(($parts->arr[0] ?? null));
			#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:117: characters 4-71
			return new HxAnon([
				"host" => $tmp,
				"port" => \Std::parseInt(($parts->arr[1] ?? null)),
			]);
		} else {
			#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:119: characters 20-48
			$tmp1 = new Host(HxString::substr(($parts->arr[1] ?? null), 2));
			#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:119: characters 4-81
			return new HxAnon([
				"host" => $tmp1,
				"port" => \Std::parseInt(($parts->arr[2] ?? null)),
			]);
		}
	}


	/**
	 * Allow the socket to listen for incoming questions. The parameter tells how many pending connections we can have until they get refused. Use `accept()` to accept incoming connections.
	 * 
	 * @param int $connections
	 * 
	 * @return void
	 */
	public function listen ($connections) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:78: characters 3-8
		throw new HxException("Not implemented");
	}


	/**
	 * Return the information about the other side of a connected socket.
	 * 
	 * @return object
	 */
	public function peer () {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:124: characters 3-45
		$r = stream_socket_get_name($this->__s, true);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:125: characters 3-55
		Socket::checkError($r, 0, "Unable to retrieve the peer name");
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:126: characters 3-23
		return $this->hpOfString($r);
	}


	/**
	 * Read the whole data available on the socket.
	 * 
	 * @return string
	 */
	public function read () {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:59: characters 3-14
		$b = "";
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:60: characters 3-36
		while (!feof($this->__s)) {
			#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:60: characters 21-36
			$b = ($b??'null') . (fgets($this->__s)??'null');
		}
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:61: characters 3-11
		return $b;
	}


	/**
	 * Change the blocking mode of the socket. A blocking socket is the default behavior. A non-blocking socket will abort blocking operations immediately by throwing a haxe.io.Error.Blocked value.
	 * 
	 * @param bool $b
	 * 
	 * @return void
	 */
	public function setBlocking ($b) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:143: characters 3-39
		$r = stream_set_blocking($this->__s, $b);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:144: characters 3-38
		Socket::checkError($r, 0, "Unable to block");
	}


	/**
	 * Allows the socket to immediately send the data when written to its output : this will cause less ping but might increase the number of packets / data size, especially when doing a lot of small writes.
	 * 
	 * @param bool $b
	 * 
	 * @return void
	 */
	public function setFastSend ($b) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:148: characters 3-8
		throw new HxException("Not implemented");
	}


	/**
	 * Gives a timeout after which blocking socket operations (such as reading and writing) will abort and throw an exception.
	 * 
	 * @param float $timeout
	 * 
	 * @return void
	 */
	public function setTimeout ($timeout) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:136: characters 3-28
		$s = (int)($timeout);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:137: characters 3-45
		$ms = (int)(($timeout - $s) * 1000000);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:138: characters 3-42
		$r = stream_set_timeout($this->__s, $s, $ms);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:139: characters 3-44
		Socket::checkError($r, 0, "Unable to set timeout");
	}


	/**
	 * Shutdown the socket, either for reading or writing.
	 * 
	 * @param bool $read
	 * @param bool $write
	 * 
	 * @return void
	 */
	public function shutdown ($read, $write) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:86: characters 3-61
		$rw = ($read && $write ? 2 : ($write ? 1 : ($read ? 0 : 2)));
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:87: characters 3-43
		$r = stream_socket_shutdown($this->__s, $rw);
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:88: characters 3-41
		Socket::checkError($r, 0, "Unable to Shutdown");
	}


	/**
	 * Block until some data is available for read on the socket.
	 * 
	 * @return void
	 */
	public function waitForRead () {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:152: characters 3-29
		Socket::select(\Array_hx::wrap([$this]), null, null);
	}


	/**
	 * Write the whole data to the socket output.
	 * 
	 * @param string $content
	 * 
	 * @return void
	 */
	public function write ($content) {
		#/usr/local/lib/haxe/std/php/_std/sys/net/Socket.hx:65: characters 3-23
		fwrite($this->__s, $content);
	}
}


Boot::registerClass(Socket::class, 'sys.net.Socket');
