<?php
/**
 * Generated by Haxe 3.4.7
 * Haxe source file: /usr/local/lib/haxe/std/haxe/Http.hx
 */

namespace haxe;

use \haxe\io\Eof;
use \php\_Boot\HxClosure;
use \haxe\io\Output;
use \haxe\ds\StringMap;
use \php\Boot;
use \php\_Boot\HxException;
use \haxe\io\BytesBuffer;
use \haxe\io\Input;
use \sys\net\Host;
use \php\_Boot\HxString;
use \haxe\io\Bytes;
use \haxe\io\_BytesData\Container;
use \haxe\io\BytesOutput;
use \php\_Boot\HxAnon;
use \haxe\io\Error;
use \php\net\SslSocket;
use \sys\net\Socket;

/**
 * This class can be used to handle Http requests consistently across
 * platforms. There are two intended usages:
 * - call `haxe.Http.requestUrl(url)` and receive the result as a `String`
 * (not available on flash)
 * - create a `new haxe.Http(url)`, register your callbacks for `onData`,
 * `onError` and `onStatus`, then call `request()`.
 */
class Http {
	/**
	 * @var object
	 */
	static public $PROXY = null;


	/**
	 * @var Bytes
	 */
	public $chunk_buf;
	/**
	 * @var int
	 */
	public $chunk_size;
	/**
	 * @var float
	 */
	public $cnxTimeout;
	/**
	 * @var object
	 */
	public $file;
	/**
	 * @var \List_hx
	 */
	public $headers;
	/**
	 * @var bool
	 */
	public $noShutdown;
	/**
	 * @var \Closure
	 * This method is called upon a successful request, with `data` containing
	 * the result String.
	 * The intended usage is to bind it to a custom function:
	 * `httpInstance.onData = function(data) { // handle result }`
	 */
	public $onData;
	/**
	 * @var \Closure
	 * This method is called upon a request error, with `msg` containing the
	 * error description.
	 * The intended usage is to bind it to a custom function:
	 * `httpInstance.onError = function(msg) { // handle error }`
	 */
	public $onError;
	/**
	 * @var \Closure
	 * This method is called upon a Http status change, with `status` being the
	 * new status.
	 * The intended usage is to bind it to a custom function:
	 * `httpInstance.onStatus = function(status) { // handle status }`
	 */
	public $onStatus;
	/**
	 * @var \List_hx
	 */
	public $params;
	/**
	 * @var string
	 */
	public $postData;
	/**
	 * @var string
	 */
	public $responseData;
	/**
	 * @var StringMap
	 */
	public $responseHeaders;
	/**
	 * @var string
	 * The url of `this` request. It is used only by the `request()` method and
	 * can be changed in order to send the same request to different target
	 * Urls.
	 */
	public $url;


	/**
	 * Makes a synchronous request to `url`.
	 * This creates a new Http instance and makes a GET request by calling its
	 * `request(false)` method.
	 * If `url` is null, the result is unspecified.
	 * 
	 * @param string $url
	 * 
	 * @return string
	 */
	static public function requestUrl ($url) {
		#/usr/local/lib/haxe/std/haxe/Http.hx:826: characters 2-24
		$h = new Http($url);
		#/usr/local/lib/haxe/std/haxe/Http.hx:830: characters 2-15
		$r = null;
		#/usr/local/lib/haxe/std/haxe/Http.hx:831: lines 831-833
		$h->onData = function ($d)  use (&$r) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:832: characters 3-8
			$r = $d;
		};
		#/usr/local/lib/haxe/std/haxe/Http.hx:834: lines 834-836
		$h->onError = function ($e) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:835: characters 3-8
			throw new HxException($e);
		};
		#/usr/local/lib/haxe/std/haxe/Http.hx:837: characters 2-18
		$h->request(false);
		#/usr/local/lib/haxe/std/haxe/Http.hx:838: characters 2-10
		return $r;
	}


	/**
	 * Creates a new Http instance with `url` as parameter.
	 * This does not do a request until `request()` is called.
	 * If `url` is null, the field url must be set to a value before making the
	 * call to `request()`, or the result is unspecified.
	 * (Php) Https (SSL) connections are allowed only if the OpenSSL extension
	 * is enabled.
	 * 
	 * @param string $url
	 * 
	 * @return void
	 */
	public function __construct ($url) {
		if (!$this->__hx__default__onData) {
			$this->__hx__default__onData = new HxClosure($this, 'onData');
			if ($this->onData === null) $this->onData = $this->__hx__default__onData;
		}
		if (!$this->__hx__default__onError) {
			$this->__hx__default__onError = new HxClosure($this, 'onError');
			if ($this->onError === null) $this->onError = $this->__hx__default__onError;
		}
		if (!$this->__hx__default__onStatus) {
			$this->__hx__default__onStatus = new HxClosure($this, 'onStatus');
			if ($this->onStatus === null) $this->onStatus = $this->__hx__default__onStatus;
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:80: characters 2-16
		$this->url = $url;
		#/usr/local/lib/haxe/std/haxe/Http.hx:81: characters 2-55
		$this->headers = new \List_hx();
		#/usr/local/lib/haxe/std/haxe/Http.hx:82: characters 2-53
		$this->params = new \List_hx();
		#/usr/local/lib/haxe/std/haxe/Http.hx:88: characters 2-17
		$this->cnxTimeout = 10;
		#/usr/local/lib/haxe/std/haxe/Http.hx:91: characters 2-78
		$this->noShutdown = !function_exists("stream_socket_shutdown");
	}


	/**
	 * @param string $header
	 * @param string $value
	 * 
	 * @return Http
	 */
	public function addHeader ($header, $value) {
		#/usr/local/lib/haxe/std/haxe/Http.hx:109: characters 2-46
		$this->headers->push(new HxAnon([
			"header" => $header,
			"value" => $value,
		]));
		#/usr/local/lib/haxe/std/haxe/Http.hx:110: characters 2-13
		return $this;
	}


	/**
	 * @param string $param
	 * @param string $value
	 * 
	 * @return Http
	 */
	public function addParameter ($param, $value) {
		#/usr/local/lib/haxe/std/haxe/Http.hx:127: characters 2-43
		$this->params->push(new HxAnon([
			"param" => $param,
			"value" => $value,
		]));
		#/usr/local/lib/haxe/std/haxe/Http.hx:128: characters 2-13
		return $this;
	}


	/**
	 * @param bool $post
	 * @param Output $api
	 * @param Socket $sock
	 * @param string $method
	 * 
	 * @return void
	 */
	public function customRequest ($post, $api, $sock = null, $method = null) {
		#/usr/local/lib/haxe/std/haxe/Http.hx:426: characters 2-26
		$this->responseData = null;
		#/usr/local/lib/haxe/std/haxe/Http.hx:427: characters 2-71
		$url_regexp = new \EReg("^(https?://)?([a-zA-Z\\.0-9_-]+)(:[0-9]+)?(.*)\$", "");
		#/usr/local/lib/haxe/std/haxe/Http.hx:428: lines 428-431
		if (!$url_regexp->match($this->url)) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:429: characters 3-25
			$this->onError("Invalid URL");
			#/usr/local/lib/haxe/std/haxe/Http.hx:430: characters 3-9
			return;
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:432: characters 2-53
		$secure = $url_regexp->matched(1) === "https://";
		#/usr/local/lib/haxe/std/haxe/Http.hx:433: lines 433-446
		if ($sock === null) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:434: lines 434-445
			if ($secure) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:436: characters 4-34
				$sock = new SslSocket();
			} else {
				#/usr/local/lib/haxe/std/haxe/Http.hx:445: characters 4-23
				$sock = new Socket();
			}
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:447: characters 2-35
		$host = $url_regexp->matched(2);
		#/usr/local/lib/haxe/std/haxe/Http.hx:448: characters 2-41
		$portString = $url_regexp->matched(3);
		#/usr/local/lib/haxe/std/haxe/Http.hx:449: characters 2-38
		$request = $url_regexp->matched(4);
		#/usr/local/lib/haxe/std/haxe/Http.hx:450: lines 450-451
		if ($request === "") {
			#/usr/local/lib/haxe/std/haxe/Http.hx:451: characters 3-16
			$request = "/";
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:452: characters 2-140
		$port = (($portString === null) || ($portString === "") ? ($secure ? 443 : 80) : \Std::parseInt(HxString::substr($portString, 1, strlen($portString) - 1)));
		#/usr/local/lib/haxe/std/haxe/Http.hx:453: characters 2-11
		$data = null;
		#/usr/local/lib/haxe/std/haxe/Http.hx:455: characters 2-33
		$multipart = $this->file !== null;
		#/usr/local/lib/haxe/std/haxe/Http.hx:456: characters 2-22
		$boundary = null;
		#/usr/local/lib/haxe/std/haxe/Http.hx:457: characters 2-17
		$uri = null;
		#/usr/local/lib/haxe/std/haxe/Http.hx:458: lines 458-495
		if ($multipart) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:459: characters 3-14
			$post = true;
			#/usr/local/lib/haxe/std/haxe/Http.hx:460: characters 3-129
			$boundary = (\Std::string(mt_rand(0, 999))??'null') . (\Std::string(mt_rand(0, 999))??'null') . (\Std::string(mt_rand(0, 999))??'null') . (\Std::string(mt_rand(0, 999))??'null');
			#/usr/local/lib/haxe/std/haxe/Http.hx:461: lines 461-462
			while (strlen($boundary) < 38) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:462: characters 4-29
				$boundary = "-" . ($boundary??'null');
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:463: characters 3-27
			$b = new \StringBuf();
			#/usr/local/lib/haxe/std/haxe/Http.hx:464: lines 464-475
			$_g_head = $this->params->h;
			#/usr/local/lib/haxe/std/haxe/Http.hx:464: lines 464-475
			while ($_g_head !== null) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:464: lines 464-475
				$val = $_g_head->item;
				#/usr/local/lib/haxe/std/haxe/Http.hx:464: lines 464-475
				$_g_head = $_g_head->next;
				#/usr/local/lib/haxe/std/haxe/Http.hx:464: lines 464-475
				$p = $val;
				#/usr/local/lib/haxe/std/haxe/Http.hx:465: characters 4-15
				$b->add("--");
				#/usr/local/lib/haxe/std/haxe/Http.hx:466: characters 4-19
				$b->add($boundary);
				#/usr/local/lib/haxe/std/haxe/Http.hx:467: characters 4-17
				$b->add("\x0D\x0A");
				#/usr/local/lib/haxe/std/haxe/Http.hx:468: characters 4-51
				$b->add("Content-Disposition: form-data; name=\"");
				#/usr/local/lib/haxe/std/haxe/Http.hx:469: characters 4-18
				$b->add($p->param);
				#/usr/local/lib/haxe/std/haxe/Http.hx:470: characters 4-14
				$b->add("\"");
				#/usr/local/lib/haxe/std/haxe/Http.hx:471: characters 4-17
				$b->add("\x0D\x0A");
				#/usr/local/lib/haxe/std/haxe/Http.hx:472: characters 4-17
				$b->add("\x0D\x0A");
				#/usr/local/lib/haxe/std/haxe/Http.hx:473: characters 4-18
				$b->add($p->value);
				#/usr/local/lib/haxe/std/haxe/Http.hx:474: characters 4-17
				$b->add("\x0D\x0A");
			}

			#/usr/local/lib/haxe/std/haxe/Http.hx:476: characters 3-14
			$b->add("--");
			#/usr/local/lib/haxe/std/haxe/Http.hx:477: characters 3-18
			$b->add($boundary);
			#/usr/local/lib/haxe/std/haxe/Http.hx:478: characters 3-16
			$b->add("\x0D\x0A");
			#/usr/local/lib/haxe/std/haxe/Http.hx:479: characters 3-50
			$b->add("Content-Disposition: form-data; name=\"");
			#/usr/local/lib/haxe/std/haxe/Http.hx:480: characters 3-20
			$b->add($this->file->param);
			#/usr/local/lib/haxe/std/haxe/Http.hx:481: characters 3-25
			$b->add("\"; filename=\"");
			#/usr/local/lib/haxe/std/haxe/Http.hx:482: characters 3-23
			$b->add($this->file->filename);
			#/usr/local/lib/haxe/std/haxe/Http.hx:483: characters 3-13
			$b->add("\"");
			#/usr/local/lib/haxe/std/haxe/Http.hx:484: characters 3-16
			$b->add("\x0D\x0A");
			#/usr/local/lib/haxe/std/haxe/Http.hx:485: characters 3-54
			$b->add("Content-Type: " . ($this->file->mimeType??'null') . "\x0D\x0A" . "\x0D\x0A");
			#/usr/local/lib/haxe/std/haxe/Http.hx:486: characters 3-21
			$uri = $b->b;
		} else {
			#/usr/local/lib/haxe/std/haxe/Http.hx:488: lines 488-494
			$_g_head1 = $this->params->h;
			#/usr/local/lib/haxe/std/haxe/Http.hx:488: lines 488-494
			while ($_g_head1 !== null) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:488: lines 488-494
				$val1 = $_g_head1->item;
				#/usr/local/lib/haxe/std/haxe/Http.hx:488: lines 488-494
				$_g_head1 = $_g_head1->next;
				#/usr/local/lib/haxe/std/haxe/Http.hx:488: lines 488-494
				$p1 = $val1;
				#/usr/local/lib/haxe/std/haxe/Http.hx:489: lines 489-492
				if ($uri === null) {
					#/usr/local/lib/haxe/std/haxe/Http.hx:490: characters 5-13
					$uri = "";
				} else {
					#/usr/local/lib/haxe/std/haxe/Http.hx:492: characters 5-15
					$uri = ($uri??'null') . "&";
				}
				#/usr/local/lib/haxe/std/haxe/Http.hx:493: characters 4-76
				$uri = ($uri??'null') . (((rawurlencode($p1->param)??'null') . "=" . (rawurlencode($p1->value)??'null'))??'null');
			}
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:497: characters 2-26
		$b1 = new \StringBuf();
		#/usr/local/lib/haxe/std/haxe/Http.hx:498: lines 498-504
		if ($method !== null) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:499: characters 3-16
			$b1->add($method);
			#/usr/local/lib/haxe/std/haxe/Http.hx:500: characters 3-13
			$b1->add(" ");
		} else if ($post) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:502: characters 3-17
			$b1->add("POST ");
		} else {
			#/usr/local/lib/haxe/std/haxe/Http.hx:504: characters 3-16
			$b1->add("GET ");
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:506: lines 506-513
		if (Http::$PROXY !== null) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:507: characters 3-19
			$b1->add("http://");
			#/usr/local/lib/haxe/std/haxe/Http.hx:508: characters 3-14
			$b1->add($host);
			#/usr/local/lib/haxe/std/haxe/Http.hx:509: lines 509-512
			if ($port !== 80) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:510: characters 4-14
				$b1->add(":");
				#/usr/local/lib/haxe/std/haxe/Http.hx:511: characters 4-15
				$b1->add($port);
			}
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:514: characters 2-16
		$b1->add($request);
		#/usr/local/lib/haxe/std/haxe/Http.hx:516: lines 516-522
		if (!$post && ($uri !== null)) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:517: lines 517-520
			if (HxString::indexOf($request, "?", 0) >= 0) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:518: characters 4-14
				$b1->add("&");
			} else {
				#/usr/local/lib/haxe/std/haxe/Http.hx:520: characters 4-14
				$b1->add("?");
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:521: characters 3-13
			$b1->add($uri);
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:523: characters 2-42
		$b1->add(" HTTP/1.1\x0D\x0AHost: " . ($host??'null') . "\x0D\x0A");
		#/usr/local/lib/haxe/std/haxe/Http.hx:524: lines 524-541
		if ($this->postData !== null) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:525: characters 3-51
			$b1->add("Content-Length: " . (strlen($this->postData)??'null') . "\x0D\x0A");
		} else if ($post && ($uri !== null)) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:527: lines 527-536
			if ($multipart || !\Lambda::exists($this->headers, function ($h) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:527: characters 56-89
				return $h->header === "Content-Type";
			})) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:528: characters 4-27
				$b1->add("Content-Type: ");
				#/usr/local/lib/haxe/std/haxe/Http.hx:529: lines 529-534
				if ($multipart) {
					#/usr/local/lib/haxe/std/haxe/Http.hx:530: characters 5-33
					$b1->add("multipart/form-data");
					#/usr/local/lib/haxe/std/haxe/Http.hx:531: characters 5-25
					$b1->add("; boundary=");
					#/usr/local/lib/haxe/std/haxe/Http.hx:532: characters 5-20
					$b1->add($boundary);
				} else {
					#/usr/local/lib/haxe/std/haxe/Http.hx:534: characters 5-47
					$b1->add("application/x-www-form-urlencoded");
				}
				#/usr/local/lib/haxe/std/haxe/Http.hx:535: characters 4-17
				$b1->add("\x0D\x0A");
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:537: lines 537-540
			if ($multipart) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:538: characters 4-77
				$b1->add("Content-Length: " . ((strlen($uri) + $this->file->size + strlen($boundary) + 6)??'null') . "\x0D\x0A");
			} else {
				#/usr/local/lib/haxe/std/haxe/Http.hx:540: characters 4-47
				$b1->add("Content-Length: " . (strlen($uri)??'null') . "\x0D\x0A");
			}
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:542: characters 2-32
		$b1->add("Connection: close\x0D\x0A");
		#/usr/local/lib/haxe/std/haxe/Http.hx:543: lines 543-548
		$_g_head2 = $this->headers->h;
		#/usr/local/lib/haxe/std/haxe/Http.hx:543: lines 543-548
		while ($_g_head2 !== null) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:543: lines 543-548
			$val2 = $_g_head2->item;
			#/usr/local/lib/haxe/std/haxe/Http.hx:543: lines 543-548
			$_g_head2 = $_g_head2->next;
			#/usr/local/lib/haxe/std/haxe/Http.hx:543: lines 543-548
			$h1 = $val2;
			#/usr/local/lib/haxe/std/haxe/Http.hx:544: characters 3-18
			$b1->add($h1->header);
			#/usr/local/lib/haxe/std/haxe/Http.hx:545: characters 3-14
			$b1->add(": ");
			#/usr/local/lib/haxe/std/haxe/Http.hx:546: characters 3-17
			$b1->add($h1->value);
			#/usr/local/lib/haxe/std/haxe/Http.hx:547: characters 3-16
			$b1->add("\x0D\x0A");
		}

		#/usr/local/lib/haxe/std/haxe/Http.hx:549: characters 2-15
		$b1->add("\x0D\x0A");
		#/usr/local/lib/haxe/std/haxe/Http.hx:550: lines 550-553
		if ($this->postData !== null) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:551: characters 3-18
			$b1->add($this->postData);
		} else if ($post && ($uri !== null)) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:553: characters 3-13
			$b1->add($uri);
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:554: lines 554-582
		try {
			#/usr/local/lib/haxe/std/haxe/Http.hx:555: lines 555-558
			if (Http::$PROXY !== null) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:556: characters 4-59
				$sock->connect(new Host(Http::$PROXY->host), Http::$PROXY->port);
			} else {
				#/usr/local/lib/haxe/std/haxe/Http.hx:558: characters 4-37
				$sock->connect(new Host($host), $port);
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:559: characters 3-27
			$sock->write($b1->b);
			#/usr/local/lib/haxe/std/haxe/Http.hx:560: lines 560-576
			if ($multipart) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:561: characters 4-23
				$bufsize = 4096;
				#/usr/local/lib/haxe/std/haxe/Http.hx:562: characters 4-43
				$buf = Bytes::alloc($bufsize);
				#/usr/local/lib/haxe/std/haxe/Http.hx:563: lines 563-571
				while ($this->file->size > 0) {
					#/usr/local/lib/haxe/std/haxe/Http.hx:564: characters 5-65
					$size = ($this->file->size > $bufsize ? $bufsize : $this->file->size);
					#/usr/local/lib/haxe/std/haxe/Http.hx:565: characters 5-17
					$len = 0;
					#/usr/local/lib/haxe/std/haxe/Http.hx:566: lines 566-568
					try {
						#/usr/local/lib/haxe/std/haxe/Http.hx:567: characters 6-41
						$len = $this->file->io->readBytes($buf, 0, $size);
					} catch (\Throwable $__hx__caught_e) {
						CallStack::saveExceptionTrace($__hx__caught_e);
						$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
						if ($__hx__real_e instanceof Eof) {
							$e = $__hx__real_e;
							#/usr/local/lib/haxe/std/haxe/Http.hx:568: characters 32-37
							break;
						} else  throw $__hx__caught_e;
					}
					#/usr/local/lib/haxe/std/haxe/Http.hx:569: characters 5-42
					$sock->output->writeFullBytes($buf, 0, $len);
					#/usr/local/lib/haxe/std/haxe/Http.hx:570: characters 5-9
					$tmp = $this->file;
					#/usr/local/lib/haxe/std/haxe/Http.hx:570: characters 5-21
					$tmp->size = $tmp->size - $len;
				}
				#/usr/local/lib/haxe/std/haxe/Http.hx:572: characters 4-22
				$sock->write("\x0D\x0A");
				#/usr/local/lib/haxe/std/haxe/Http.hx:573: characters 4-20
				$sock->write("--");
				#/usr/local/lib/haxe/std/haxe/Http.hx:574: characters 4-24
				$sock->write($boundary);
				#/usr/local/lib/haxe/std/haxe/Http.hx:575: characters 4-20
				$sock->write("--");
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:577: characters 3-29
			$this->readHttpResponse($api, $sock);
			#/usr/local/lib/haxe/std/haxe/Http.hx:578: characters 3-15
			$sock->close();
		} catch (\Throwable $__hx__caught_e) {
			CallStack::saveExceptionTrace($__hx__caught_e);
			$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
			$e1 = $__hx__real_e;
			#/usr/local/lib/haxe/std/haxe/Http.hx:580: characters 3-44
			try {
				#/usr/local/lib/haxe/std/haxe/Http.hx:580: characters 7-19
				$sock->close();
			} catch (\Throwable $__hx__caught_e) {
				CallStack::saveExceptionTrace($__hx__caught_e);
				$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
				$e2 = $__hx__real_e;
							}
			#/usr/local/lib/haxe/std/haxe/Http.hx:581: characters 3-25
			$this->onError(\Std::string($e1));
		}
	}


	/**
	 * @param string $argname
	 * @param string $filename
	 * @param Input $file
	 * @param int $size
	 * @param string $mimeType
	 * 
	 * @return void
	 */
	public function fileTransfer ($argname, $filename, $file, $size, $mimeType = "application/octet-stream") {
		#/usr/local/lib/haxe/std/haxe/Http.hx:422: characters 2-99
		if ($mimeType === null) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:422: characters 2-99
			$mimeType = "application/octet-stream";
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:422: characters 2-99
		$this->file = new HxAnon([
			"param" => $argname,
			"filename" => $filename,
			"io" => $file,
			"size" => $size,
			"mimeType" => $mimeType,
		]);
	}


	/**
	 * Note: Deprecated in 4.0
	 * 
	 * @param string $argname
	 * @param string $filename
	 * @param Input $file
	 * @param int $size
	 * @param string $mimeType
	 * 
	 * @return void
	 */
	public function fileTransfert ($argname, $filename, $file, $size, $mimeType = "application/octet-stream") {
		#/usr/local/lib/haxe/std/haxe/Http.hx:418: characters 5-58
		if ($mimeType === null) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:418: characters 5-58
			$mimeType = "application/octet-stream";
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:418: characters 5-58
		$this->fileTransfer($argname, $filename, $file, $size, $mimeType);
	}


	/**
	 * This method is called upon a successful request, with `data` containing
	 * the result String.
	 * The intended usage is to bind it to a custom function:
	 * `httpInstance.onData = function(data) { // handle result }`
	 * 
	 * @param string $data
	 * 
	 * @return void
	 */
	public function onData ($data)
	{
		if ($this->onData !== $this->__hx__default__onData) return call_user_func_array($this->onData, func_get_args());
			}
	protected $__hx__default__onData;


	/**
	 * This method is called upon a request error, with `msg` containing the
	 * error description.
	 * The intended usage is to bind it to a custom function:
	 * `httpInstance.onError = function(msg) { // handle error }`
	 * 
	 * @param string $msg
	 * 
	 * @return void
	 */
	public function onError ($msg)
	{
		if ($this->onError !== $this->__hx__default__onError) return call_user_func_array($this->onError, func_get_args());
			}
	protected $__hx__default__onError;


	/**
	 * This method is called upon a Http status change, with `status` being the
	 * new status.
	 * The intended usage is to bind it to a custom function:
	 * `httpInstance.onStatus = function(status) { // handle status }`
	 * 
	 * @param int $status
	 * 
	 * @return void
	 */
	public function onStatus ($status)
	{
		if ($this->onStatus !== $this->__hx__default__onStatus) return call_user_func_array($this->onStatus, func_get_args());
			}
	protected $__hx__default__onStatus;


	/**
	 * @param \EReg $chunk_re
	 * @param Output $api
	 * @param Bytes $buf
	 * @param int $len
	 * 
	 * @return bool
	 */
	public function readChunk ($chunk_re, $api, $buf, $len) {
		#/usr/local/lib/haxe/std/haxe/Http.hx:728: lines 728-762
		if ($this->chunk_size === null) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:729: lines 729-736
			if ($this->chunk_buf !== null) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:730: characters 4-38
				$b = new BytesBuffer();
				#/usr/local/lib/haxe/std/haxe/Http.hx:731: characters 4-20
				($b->b .= $this->chunk_buf->b->s);
				#/usr/local/lib/haxe/std/haxe/Http.hx:732: characters 4-25
				if (($len < 0) || ($len > $buf->length)) {
					#/usr/local/lib/haxe/std/haxe/Http.hx:732: characters 4-25
					throw new HxException(Error::OutsideBounds());
				} else {
					#/usr/local/lib/haxe/std/haxe/Http.hx:732: characters 4-25
					($b->b .= (new Container(substr($buf->b->s, 0, $len)))->s);
				}
				#/usr/local/lib/haxe/std/haxe/Http.hx:733: characters 4-22
				$buf = $b->getBytes();
				#/usr/local/lib/haxe/std/haxe/Http.hx:734: characters 4-27
				$len = $len + $this->chunk_buf->length;
				#/usr/local/lib/haxe/std/haxe/Http.hx:735: characters 4-20
				$this->chunk_buf = null;
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:740: lines 740-754
			if ($chunk_re->match($buf->toString())) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:742: characters 4-34
				$p = $chunk_re->matchedPos();
				#/usr/local/lib/haxe/std/haxe/Http.hx:743: lines 743-753
				if ($p->len <= $len) {
					#/usr/local/lib/haxe/std/haxe/Http.hx:744: characters 5-36
					$cstr = $chunk_re->matched(1);
					#/usr/local/lib/haxe/std/haxe/Http.hx:745: characters 5-41
					$this->chunk_size = \Std::parseInt("0x" . ($cstr??'null'));
					#/usr/local/lib/haxe/std/haxe/Http.hx:746: lines 746-750
					if ($cstr === "0") {
						#/usr/local/lib/haxe/std/haxe/Http.hx:747: characters 6-23
						$this->chunk_size = null;
						#/usr/local/lib/haxe/std/haxe/Http.hx:748: characters 6-22
						$this->chunk_buf = null;
						#/usr/local/lib/haxe/std/haxe/Http.hx:749: characters 6-18
						return false;
					}
					#/usr/local/lib/haxe/std/haxe/Http.hx:751: characters 5-17
					$len = $len - $p->len;
					#/usr/local/lib/haxe/std/haxe/Http.hx:752: characters 35-53
					$pos = $p->len;
					#/usr/local/lib/haxe/std/haxe/Http.hx:752: characters 35-53
					$tmp = null;
					#/usr/local/lib/haxe/std/haxe/Http.hx:752: characters 35-53
					if (($pos < 0) || ($len < 0) || (($pos + $len) > $buf->length)) {
						#/usr/local/lib/haxe/std/haxe/Http.hx:752: characters 35-53
						throw new HxException(Error::OutsideBounds());
					} else {
						#/usr/local/lib/haxe/std/haxe/Http.hx:752: characters 35-53
						$tmp = new Bytes($len, new Container(substr($buf->b->s, $pos, $len)));
					}
					#/usr/local/lib/haxe/std/haxe/Http.hx:752: characters 5-58
					return $this->readChunk($chunk_re, $api, $tmp, $len);
				}
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:756: lines 756-759
			if ($len > 10) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:757: characters 4-28
				$this->onError("Invalid chunk");
				#/usr/local/lib/haxe/std/haxe/Http.hx:758: characters 4-16
				return false;
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:760: characters 15-29
			$tmp1 = null;
			#/usr/local/lib/haxe/std/haxe/Http.hx:760: characters 15-29
			if (($len < 0) || ($len > $buf->length)) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:760: characters 15-29
				throw new HxException(Error::OutsideBounds());
			} else {
				#/usr/local/lib/haxe/std/haxe/Http.hx:760: characters 15-29
				$tmp1 = new Bytes($len, new Container(substr($buf->b->s, 0, $len)));
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:760: characters 3-29
			$this->chunk_buf = $tmp1;
			#/usr/local/lib/haxe/std/haxe/Http.hx:761: characters 3-14
			return true;
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:763: lines 763-767
		if ($this->chunk_size > $len) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:764: characters 3-13
			$tmp2 = $this;
			#/usr/local/lib/haxe/std/haxe/Http.hx:764: characters 3-20
			$tmp2->chunk_size = $tmp2->chunk_size - $len;
			#/usr/local/lib/haxe/std/haxe/Http.hx:765: characters 3-28
			$api->writeBytes($buf, 0, $len);
			#/usr/local/lib/haxe/std/haxe/Http.hx:766: characters 3-14
			return true;
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:768: characters 2-27
		$end = $this->chunk_size + 2;
		#/usr/local/lib/haxe/std/haxe/Http.hx:769: lines 769-777
		if ($len >= $end) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:770: lines 770-771
			if ($this->chunk_size > 0) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:771: characters 4-36
				$api->writeBytes($buf, 0, $this->chunk_size);
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:772: characters 3-13
			$len = $len - $end;
			#/usr/local/lib/haxe/std/haxe/Http.hx:773: characters 3-20
			$this->chunk_size = null;
			#/usr/local/lib/haxe/std/haxe/Http.hx:774: lines 774-775
			if ($len === 0) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:775: characters 4-15
				return true;
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:776: characters 33-49
			$tmp3 = null;
			#/usr/local/lib/haxe/std/haxe/Http.hx:776: characters 33-49
			if (($end < 0) || ($len < 0) || (($end + $len) > $buf->length)) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:776: characters 33-49
				throw new HxException(Error::OutsideBounds());
			} else {
				#/usr/local/lib/haxe/std/haxe/Http.hx:776: characters 33-49
				$tmp3 = new Bytes($len, new Container(substr($buf->b->s, $end, $len)));
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:776: characters 3-54
			return $this->readChunk($chunk_re, $api, $tmp3, $len);
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:778: lines 778-779
		if ($this->chunk_size > 0) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:779: characters 3-35
			$api->writeBytes($buf, 0, $this->chunk_size);
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:780: characters 2-12
		$tmp4 = $this;
		#/usr/local/lib/haxe/std/haxe/Http.hx:780: characters 2-19
		$tmp4->chunk_size = $tmp4->chunk_size - $len;
		#/usr/local/lib/haxe/std/haxe/Http.hx:781: characters 2-13
		return true;
	}


	/**
	 * @param Output $api
	 * @param Socket $sock
	 * 
	 * @return void
	 */
	public function readHttpResponse ($api, $sock) {
		#/usr/local/lib/haxe/std/haxe/Http.hx:587: characters 2-36
		$b = new BytesBuffer();
		#/usr/local/lib/haxe/std/haxe/Http.hx:588: characters 2-12
		$k = 4;
		#/usr/local/lib/haxe/std/haxe/Http.hx:589: characters 2-33
		$s = Bytes::alloc(4);
		#/usr/local/lib/haxe/std/haxe/Http.hx:590: characters 2-29
		$sock->setTimeout($this->cnxTimeout);
		#/usr/local/lib/haxe/std/haxe/Http.hx:591: lines 591-647
		while (true) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:592: characters 3-39
			$p = $sock->input->readBytes($s, 0, $k);
			#/usr/local/lib/haxe/std/haxe/Http.hx:593: lines 593-594
			while ($p !== $k) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:594: characters 4-40
				$p = $p + $sock->input->readBytes($s, $p, $k - $p);
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:595: characters 3-20
			if (($k < 0) || ($k > $s->length)) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:595: characters 3-20
				throw new HxException(Error::OutsideBounds());
			} else {
				#/usr/local/lib/haxe/std/haxe/Http.hx:595: characters 3-20
				($b->b .= (new Container(substr($s->b->s, 0, $k)))->s);
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:596: lines 596-646
			switch ($k) {
				case 1:
					#/usr/local/lib/haxe/std/haxe/Http.hx:598: characters 4-21
					$c = ord($s->b->s[0]);
					#/usr/local/lib/haxe/std/haxe/Http.hx:599: lines 599-600
					if ($c === 10) {
						#/usr/local/lib/haxe/std/haxe/Http.hx:600: characters 5-10
						break 2;
					}
					#/usr/local/lib/haxe/std/haxe/Http.hx:601: lines 601-604
					if ($c === 13) {
						#/usr/local/lib/haxe/std/haxe/Http.hx:602: characters 5-10
						$k = 3;
					} else {
						#/usr/local/lib/haxe/std/haxe/Http.hx:604: characters 5-10
						$k = 4;
					}
					break;
				case 2:
					#/usr/local/lib/haxe/std/haxe/Http.hx:606: characters 4-21
					$c1 = ord($s->b->s[1]);
					#/usr/local/lib/haxe/std/haxe/Http.hx:607: lines 607-614
					if ($c1 === 10) {
						#/usr/local/lib/haxe/std/haxe/Http.hx:608: lines 608-609
						if (ord($s->b->s[0]) === 13) {
							#/usr/local/lib/haxe/std/haxe/Http.hx:609: characters 6-11
							break 2;
						}
						#/usr/local/lib/haxe/std/haxe/Http.hx:610: characters 5-10
						$k = 4;
					} else if ($c1 === 13) {
						#/usr/local/lib/haxe/std/haxe/Http.hx:612: characters 5-10
						$k = 3;
					} else {
						#/usr/local/lib/haxe/std/haxe/Http.hx:614: characters 5-10
						$k = 4;
					}
					break;
				case 3:
					#/usr/local/lib/haxe/std/haxe/Http.hx:616: characters 4-21
					$c2 = ord($s->b->s[2]);
					#/usr/local/lib/haxe/std/haxe/Http.hx:617: lines 617-630
					if ($c2 === 10) {
						#/usr/local/lib/haxe/std/haxe/Http.hx:618: lines 618-623
						if (ord($s->b->s[1]) !== 13) {
							#/usr/local/lib/haxe/std/haxe/Http.hx:619: characters 6-11
							$k = 4;
						} else if (ord($s->b->s[0]) !== 10) {
							#/usr/local/lib/haxe/std/haxe/Http.hx:621: characters 6-11
							$k = 2;
						} else {
							#/usr/local/lib/haxe/std/haxe/Http.hx:623: characters 6-11
							break 2;
						}
					} else if ($c2 === 13) {
						#/usr/local/lib/haxe/std/haxe/Http.hx:625: lines 625-628
						if ((ord($s->b->s[1]) !== 10) || (ord($s->b->s[0]) !== 13)) {
							#/usr/local/lib/haxe/std/haxe/Http.hx:626: characters 6-11
							$k = 1;
						} else {
							#/usr/local/lib/haxe/std/haxe/Http.hx:628: characters 6-11
							$k = 3;
						}
					} else {
						#/usr/local/lib/haxe/std/haxe/Http.hx:630: characters 5-10
						$k = 4;
					}
					break;
				case 4:
					#/usr/local/lib/haxe/std/haxe/Http.hx:632: characters 4-21
					$c3 = ord($s->b->s[3]);
					#/usr/local/lib/haxe/std/haxe/Http.hx:633: lines 633-645
					if ($c3 === 10) {
						#/usr/local/lib/haxe/std/haxe/Http.hx:634: lines 634-639
						if (ord($s->b->s[2]) !== 13) {
							#/usr/local/lib/haxe/std/haxe/Http.hx:635: characters 6-14
							continue 2;
						} else if ((ord($s->b->s[1]) !== 10) || (ord($s->b->s[0]) !== 13)) {
							#/usr/local/lib/haxe/std/haxe/Http.hx:637: characters 6-11
							$k = 2;
						} else {
							#/usr/local/lib/haxe/std/haxe/Http.hx:639: characters 6-11
							break 2;
						}
					} else if ($c3 === 13) {
						#/usr/local/lib/haxe/std/haxe/Http.hx:641: lines 641-644
						if ((ord($s->b->s[2]) !== 10) || (ord($s->b->s[1]) !== 13)) {
							#/usr/local/lib/haxe/std/haxe/Http.hx:642: characters 6-11
							$k = 3;
						} else {
							#/usr/local/lib/haxe/std/haxe/Http.hx:644: characters 6-11
							$k = 1;
						}
					}
					break;
			}
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:651: characters 2-54
		$headers = HxString::split($b->getBytes()->toString(), "\x0D\x0A");
		#/usr/local/lib/haxe/std/haxe/Http.hx:653: characters 17-32
		if ($headers->length > 0) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:653: characters 17-32
			$headers->length--;
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:653: characters 2-33
		$response = array_shift($headers->arr);
		#/usr/local/lib/haxe/std/haxe/Http.hx:654: characters 2-31
		$rp = HxString::split($response, " ");
		#/usr/local/lib/haxe/std/haxe/Http.hx:655: characters 2-35
		$status = \Std::parseInt(($rp->arr[1] ?? null));
		#/usr/local/lib/haxe/std/haxe/Http.hx:656: lines 656-657
		if (($status === 0) || ($status === null)) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:657: characters 3-8
			throw new HxException("Response status error");
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:660: characters 2-15
		if ($headers->length > 0) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:660: characters 2-15
			$headers->length--;
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:660: characters 2-15
		array_pop($headers->arr);

		#/usr/local/lib/haxe/std/haxe/Http.hx:661: characters 2-15
		if ($headers->length > 0) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:661: characters 2-15
			$headers->length--;
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:661: characters 2-15
		array_pop($headers->arr);

		#/usr/local/lib/haxe/std/haxe/Http.hx:662: characters 2-43
		$this->responseHeaders = new StringMap();
		#/usr/local/lib/haxe/std/haxe/Http.hx:663: characters 2-18
		$size = null;
		#/usr/local/lib/haxe/std/haxe/Http.hx:664: characters 2-22
		$chunked = false;
		#/usr/local/lib/haxe/std/haxe/Http.hx:665: lines 665-678
		$_g = 0;
		#/usr/local/lib/haxe/std/haxe/Http.hx:665: lines 665-678
		while ($_g < $headers->length) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:665: characters 7-12
			$hline = ($headers->arr[$_g] ?? null);
			#/usr/local/lib/haxe/std/haxe/Http.hx:665: lines 665-678
			$_g = $_g + 1;
			#/usr/local/lib/haxe/std/haxe/Http.hx:666: characters 3-29
			$a = HxString::split($hline, ": ");
			#/usr/local/lib/haxe/std/haxe/Http.hx:667: characters 15-24
			if ($a->length > 0) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:667: characters 15-24
				$a->length--;
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:667: characters 3-25
			$hname = array_shift($a->arr);
			#/usr/local/lib/haxe/std/haxe/Http.hx:668: characters 3-57
			$hval = ($a->length === 1 ? ($a->arr[0] ?? null) : $a->join(": "));
			#/usr/local/lib/haxe/std/haxe/Http.hx:669: characters 10-56
			$hval = ltrim(rtrim($hval));
			#/usr/local/lib/haxe/std/haxe/Http.hx:670: characters 3-35
			$this->responseHeaders->data[$hname] = $hval;
			#/usr/local/lib/haxe/std/haxe/Http.hx:671: characters 10-29
			$_g1 = HxString::toLowerCase($hname);
			#/usr/local/lib/haxe/std/haxe/Http.hx:671: characters 10-29
			switch ($_g1) {
				case "content-length":
					#/usr/local/lib/haxe/std/haxe/Http.hx:674: characters 5-30
					$size = \Std::parseInt($hval);
					break;
				case "transfer-encoding":
					#/usr/local/lib/haxe/std/haxe/Http.hx:676: characters 5-48
					$chunked = HxString::toLowerCase($hval) === "chunked";
					break;
			}

		}

		#/usr/local/lib/haxe/std/haxe/Http.hx:680: characters 2-18
		$this->onStatus($status);
		#/usr/local/lib/haxe/std/haxe/Http.hx:682: characters 2-45
		$chunk_re = new \EReg("^([0-9A-Fa-f]+)[ ]*\x0D\x0A", "m");
		#/usr/local/lib/haxe/std/haxe/Http.hx:683: characters 2-19
		$this->chunk_size = null;
		#/usr/local/lib/haxe/std/haxe/Http.hx:684: characters 2-18
		$this->chunk_buf = null;
		#/usr/local/lib/haxe/std/haxe/Http.hx:686: characters 2-21
		$bufsize = 1024;
		#/usr/local/lib/haxe/std/haxe/Http.hx:687: characters 2-41
		$buf = Bytes::alloc($bufsize);
		#/usr/local/lib/haxe/std/haxe/Http.hx:688: lines 688-719
		if ($chunked) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:689: lines 689-697
			try {
				#/usr/local/lib/haxe/std/haxe/Http.hx:690: lines 690-694
				while (true) {
					#/usr/local/lib/haxe/std/haxe/Http.hx:691: characters 5-51
					$len = $sock->input->readBytes($buf, 0, $bufsize);
					#/usr/local/lib/haxe/std/haxe/Http.hx:692: lines 692-693
					if (!$this->readChunk($chunk_re, $api, $buf, $len)) {
						#/usr/local/lib/haxe/std/haxe/Http.hx:693: characters 6-11
						break;
					}
				}
			} catch (\Throwable $__hx__caught_e) {
				CallStack::saveExceptionTrace($__hx__caught_e);
				$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
				if ($__hx__real_e instanceof Eof) {
					$e = $__hx__real_e;
					#/usr/local/lib/haxe/std/haxe/Http.hx:696: characters 4-9
					throw new HxException("Transfer aborted");
				} else  throw $__hx__caught_e;
			}
		} else if ($size === null) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:699: lines 699-700
			if (!$this->noShutdown) {
				#/usr/local/lib/haxe/std/haxe/Http.hx:700: characters 4-29
				$sock->shutdown(false, true);
			}
			#/usr/local/lib/haxe/std/haxe/Http.hx:701: lines 701-707
			try {
				#/usr/local/lib/haxe/std/haxe/Http.hx:702: lines 702-705
				while (true) {
					#/usr/local/lib/haxe/std/haxe/Http.hx:703: characters 5-51
					$len1 = $sock->input->readBytes($buf, 0, $bufsize);
					#/usr/local/lib/haxe/std/haxe/Http.hx:704: characters 5-30
					$api->writeBytes($buf, 0, $len1);
				}
			} catch (\Throwable $__hx__caught_e) {
				CallStack::saveExceptionTrace($__hx__caught_e);
				$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
				if ($__hx__real_e instanceof Eof) {
					$e1 = $__hx__real_e;
									} else  throw $__hx__caught_e;
			}
		} else {
			#/usr/local/lib/haxe/std/haxe/Http.hx:709: characters 3-20
			$api->prepare($size);
			#/usr/local/lib/haxe/std/haxe/Http.hx:710: lines 710-718
			try {
				#/usr/local/lib/haxe/std/haxe/Http.hx:711: lines 711-715
				while ($size > 0) {
					#/usr/local/lib/haxe/std/haxe/Http.hx:712: characters 5-82
					$len2 = $sock->input->readBytes($buf, 0, ($size > $bufsize ? $bufsize : $size));
					#/usr/local/lib/haxe/std/haxe/Http.hx:713: characters 5-30
					$api->writeBytes($buf, 0, $len2);
					#/usr/local/lib/haxe/std/haxe/Http.hx:714: characters 5-16
					$size = $size - $len2;
				}
			} catch (\Throwable $__hx__caught_e) {
				CallStack::saveExceptionTrace($__hx__caught_e);
				$__hx__real_e = ($__hx__caught_e instanceof HxException ? $__hx__caught_e->e : $__hx__caught_e);
				if ($__hx__real_e instanceof Eof) {
					$e2 = $__hx__real_e;
					#/usr/local/lib/haxe/std/haxe/Http.hx:717: characters 4-9
					throw new HxException("Transfer aborted");
				} else  throw $__hx__caught_e;
			}
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:720: lines 720-721
		if ($chunked && (($this->chunk_size !== null) || ($this->chunk_buf !== null))) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:721: characters 3-8
			throw new HxException("Invalid chunk");
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:722: lines 722-723
		if (($status < 200) || ($status >= 400)) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:723: characters 3-8
			throw new HxException("Http Error #" . ($status??'null'));
		}
		#/usr/local/lib/haxe/std/haxe/Http.hx:724: characters 2-13
		$api->close();
	}


	/**
	 * Sends `this` Http request to the Url specified by `this.url`.
	 * If `post` is true, the request is sent as POST request, otherwise it is
	 * sent as GET request.
	 * Depending on the outcome of the request, this method calls the
	 * `onStatus()`, `onError()` or `onData()` callback functions.
	 * If `this.url` is null, the result is unspecified.
	 * If `this.url` is an invalid or inaccessible Url, the `onError()` callback
	 * function is called.
	 * [js] If `this.async` is false, the callback functions are called before
	 * this method returns.
	 * 
	 * @param bool $post
	 * 
	 * @return void
	 */
	public function request ($post = null) {
		#/usr/local/lib/haxe/std/haxe/Http.hx:189: lines 189-409
		$_gthis = $this;
		#/usr/local/lib/haxe/std/haxe/Http.hx:190: characters 2-16
		$me = $this;
		#/usr/local/lib/haxe/std/haxe/Http.hx:386: characters 2-16
		$me1 = $this;
		#/usr/local/lib/haxe/std/haxe/Http.hx:387: characters 2-41
		$output = new BytesOutput();
		#/usr/local/lib/haxe/std/haxe/Http.hx:388: characters 2-20
		$old = $this->onError;
		#/usr/local/lib/haxe/std/haxe/Http.hx:389: characters 2-18
		$err = false;
		#/usr/local/lib/haxe/std/haxe/Http.hx:390: lines 390-400
		$this->onError = function ($e)  use (&$err, &$old, &$_gthis, &$me1, &$output) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:394: characters 3-49
			$me1->responseData = $output->getBytes()->toString();
			#/usr/local/lib/haxe/std/haxe/Http.hx:396: characters 3-13
			$err = true;
			#/usr/local/lib/haxe/std/haxe/Http.hx:398: characters 3-16
			$_gthis->onError = $old;
			#/usr/local/lib/haxe/std/haxe/Http.hx:399: characters 3-13
			$_gthis->onError($e);
		};
		#/usr/local/lib/haxe/std/haxe/Http.hx:401: characters 2-28
		$this->customRequest($post, $output);
		#/usr/local/lib/haxe/std/haxe/Http.hx:402: lines 402-406
		if (!$err) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:406: characters 3-60
			$me1->onData($me1->responseData = $output->getBytes()->toString());
		}
	}


	/**
	 * Sets the header identified as `header` to value `value`.
	 * If `header` or `value` are null, the result is unspecified.
	 * This method provides a fluent interface.
	 * 
	 * @param string $header
	 * @param string $value
	 * 
	 * @return Http
	 */
	public function setHeader ($header, $value) {
		#/usr/local/lib/haxe/std/haxe/Http.hx:103: characters 2-73
		$this->headers = \Lambda::filter($this->headers, function ($h)  use (&$header) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:103: characters 47-72
			return $h->header !== $header;
		});
		#/usr/local/lib/haxe/std/haxe/Http.hx:104: characters 2-46
		$this->headers->push(new HxAnon([
			"header" => $header,
			"value" => $value,
		]));
		#/usr/local/lib/haxe/std/haxe/Http.hx:105: characters 2-13
		return $this;
	}


	/**
	 * Sets the parameter identified as `param` to value `value`.
	 * If `header` or `value` are null, the result is unspecified.
	 * This method provides a fluent interface.
	 * 
	 * @param string $param
	 * @param string $value
	 * 
	 * @return Http
	 */
	public function setParameter ($param, $value) {
		#/usr/local/lib/haxe/std/haxe/Http.hx:121: characters 2-69
		$this->params = \Lambda::filter($this->params, function ($p)  use (&$param) {
			#/usr/local/lib/haxe/std/haxe/Http.hx:121: characters 45-68
			return $p->param !== $param;
		});
		#/usr/local/lib/haxe/std/haxe/Http.hx:122: characters 2-43
		$this->params->push(new HxAnon([
			"param" => $param,
			"value" => $value,
		]));
		#/usr/local/lib/haxe/std/haxe/Http.hx:123: characters 2-13
		return $this;
	}


	/**
	 * Sets the post data of `this` Http request to `data`.
	 * There can only be one post data per request. Subsequent calls overwrite
	 * the previously set value.
	 * If `data` is null, the post data is considered to be absent.
	 * This method provides a fluent interface.
	 * 
	 * @param string $data
	 * 
	 * @return Http
	 */
	public function setPostData ($data) {
		#/usr/local/lib/haxe/std/haxe/Http.hx:142: characters 2-17
		$this->postData = $data;
		#/usr/local/lib/haxe/std/haxe/Http.hx:143: characters 2-13
		return $this;
	}
}


Boot::registerClass(Http::class, 'haxe.Http');
