<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ da28365)
 * Haxe source file: /usr/local/lib/haxe/std/haxe/macro/Expr.hx
 */

namespace haxe\macro;

use \php\Boot;
use \php\_Boot\HxEnum;

/**
 * A binary operator.
 * @see https://haxe.org/manual/types-numeric-operators.html
 */
class Binop extends HxEnum {
	/**
	 * `+`
	 * 
	 * @return Binop
	 */
	static public function OpAdd () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpAdd', 0, []);
		return $inst;
	}


	/**
	 * `&`
	 * 
	 * @return Binop
	 */
	static public function OpAnd () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpAnd', 11, []);
		return $inst;
	}


	/**
	 * `=>`
	 * 
	 * @return Binop
	 */
	static public function OpArrow () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpArrow', 22, []);
		return $inst;
	}


	/**
	 * `=`
	 * 
	 * @return Binop
	 */
	static public function OpAssign () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpAssign', 4, []);
		return $inst;
	}


	/**
	 * `+=`
	 * `-=`
	 * `/=`
	 * `*=`
	 * `<<=`
	 * `>>=`
	 * `>>>=`
	 * `|=`
	 * `&=`
	 * `^=`
	 * `%=`
	 * 
	 * @param Binop $op
	 * 
	 * @return Binop
	 */
	static public function OpAssignOp ($op) {
		return new Binop('OpAssignOp', 20, [$op]);
	}


	/**
	 * `&&`
	 * 
	 * @return Binop
	 */
	static public function OpBoolAnd () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpBoolAnd', 14, []);
		return $inst;
	}


	/**
	 * `||`
	 * 
	 * @return Binop
	 */
	static public function OpBoolOr () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpBoolOr', 15, []);
		return $inst;
	}


	/**
	 * `/`
	 * 
	 * @return Binop
	 */
	static public function OpDiv () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpDiv', 2, []);
		return $inst;
	}


	/**
	 * `==`
	 * 
	 * @return Binop
	 */
	static public function OpEq () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpEq', 5, []);
		return $inst;
	}


	/**
	 * `>`
	 * 
	 * @return Binop
	 */
	static public function OpGt () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpGt', 7, []);
		return $inst;
	}


	/**
	 * `>=`
	 * 
	 * @return Binop
	 */
	static public function OpGte () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpGte', 8, []);
		return $inst;
	}


	/**
	 * `in`
	 * 
	 * @return Binop
	 */
	static public function OpIn () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpIn', 23, []);
		return $inst;
	}


	/**
	 * `...`
	 * 
	 * @return Binop
	 */
	static public function OpInterval () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpInterval', 21, []);
		return $inst;
	}


	/**
	 * `<`
	 * 
	 * @return Binop
	 */
	static public function OpLt () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpLt', 9, []);
		return $inst;
	}


	/**
	 * `<=`
	 * 
	 * @return Binop
	 */
	static public function OpLte () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpLte', 10, []);
		return $inst;
	}


	/**
	 * `%`
	 * 
	 * @return Binop
	 */
	static public function OpMod () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpMod', 19, []);
		return $inst;
	}


	/**
	 * `*`
	 * 
	 * @return Binop
	 */
	static public function OpMult () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpMult', 1, []);
		return $inst;
	}


	/**
	 * `!=`
	 * 
	 * @return Binop
	 */
	static public function OpNotEq () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpNotEq', 6, []);
		return $inst;
	}


	/**
	 * `|`
	 * 
	 * @return Binop
	 */
	static public function OpOr () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpOr', 12, []);
		return $inst;
	}


	/**
	 * `<<`
	 * 
	 * @return Binop
	 */
	static public function OpShl () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpShl', 16, []);
		return $inst;
	}


	/**
	 * `>>`
	 * 
	 * @return Binop
	 */
	static public function OpShr () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpShr', 17, []);
		return $inst;
	}


	/**
	 * `-`
	 * 
	 * @return Binop
	 */
	static public function OpSub () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpSub', 3, []);
		return $inst;
	}


	/**
	 * `>>>`
	 * 
	 * @return Binop
	 */
	static public function OpUShr () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpUShr', 18, []);
		return $inst;
	}


	/**
	 * `^`
	 * 
	 * @return Binop
	 */
	static public function OpXor () {
		static $inst = null;
		if (!$inst) $inst = new Binop('OpXor', 13, []);
		return $inst;
	}


	/**
	 * Returns array of (constructorIndex => constructorName)
	 *
	 * @return string[]
	 */
	static public function __hx__list () {
		return [
			0 => 'OpAdd',
			11 => 'OpAnd',
			22 => 'OpArrow',
			4 => 'OpAssign',
			20 => 'OpAssignOp',
			14 => 'OpBoolAnd',
			15 => 'OpBoolOr',
			2 => 'OpDiv',
			5 => 'OpEq',
			7 => 'OpGt',
			8 => 'OpGte',
			23 => 'OpIn',
			21 => 'OpInterval',
			9 => 'OpLt',
			10 => 'OpLte',
			19 => 'OpMod',
			1 => 'OpMult',
			6 => 'OpNotEq',
			12 => 'OpOr',
			16 => 'OpShl',
			17 => 'OpShr',
			3 => 'OpSub',
			18 => 'OpUShr',
			13 => 'OpXor',
		];
	}


	/**
	 * Returns array of (constructorName => parametersCount)
	 *
	 * @return int[]
	 */
	static public function __hx__paramsCount () {
		return [
			'OpAdd' => 0,
			'OpAnd' => 0,
			'OpArrow' => 0,
			'OpAssign' => 0,
			'OpAssignOp' => 1,
			'OpBoolAnd' => 0,
			'OpBoolOr' => 0,
			'OpDiv' => 0,
			'OpEq' => 0,
			'OpGt' => 0,
			'OpGte' => 0,
			'OpIn' => 0,
			'OpInterval' => 0,
			'OpLt' => 0,
			'OpLte' => 0,
			'OpMod' => 0,
			'OpMult' => 0,
			'OpNotEq' => 0,
			'OpOr' => 0,
			'OpShl' => 0,
			'OpShr' => 0,
			'OpSub' => 0,
			'OpUShr' => 0,
			'OpXor' => 0,
		];
	}
}


Boot::registerClass(Binop::class, 'haxe.macro.Binop');
