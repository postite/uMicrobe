<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ da28365)
 * Haxe source file: /usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx
 */

namespace haxe\crypto;

use \php\Boot;
use \php\_Boot\HxException;
use \haxe\io\Bytes;
use \haxe\io\_BytesData\Container;

/**
 * Allows one to encode/decode String and bytes using a power of two base dictionary.
 */
class BaseCode {
	/**
	 * @var Bytes
	 */
	public $base;
	/**
	 * @var int
	 */
	public $nbits;
	/**
	 * @var \Array_hx
	 */
	public $tbl;


	/**
	 * @param string $s
	 * @param string $base
	 * 
	 * @return string
	 */
	static public function decode ($s, $base) {
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:133: characters 24-52
		$base1 = strlen($base);
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:133: characters 3-54
		$b = new BaseCode(new Bytes($base1, new Container($base)));
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:134: characters 3-27
		return $b->decodeString($s);
	}


	/**
	 * @param string $s
	 * @param string $base
	 * 
	 * @return string
	 */
	static public function encode ($s, $base) {
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:128: characters 24-52
		$base1 = strlen($base);
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:128: characters 3-54
		$b = new BaseCode(new Bytes($base1, new Container($base)));
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:129: characters 3-27
		return $b->encodeString($s);
	}


	/**
	 * @param Bytes $base
	 * 
	 * @return void
	 */
	public function __construct ($base) {
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:34: characters 3-25
		$len = $base->length;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:35: characters 3-17
		$nbits = 1;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:36: lines 36-37
		while ($len > (1 << $nbits)) {
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:37: characters 4-11
			$nbits = $nbits + 1;
		}
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:38: lines 38-39
		if (($nbits > 8) || ($len !== (1 << $nbits))) {
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:39: characters 4-9
			throw new HxException("BaseCode : base length must be a power of two.");
		}
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:40: characters 3-19
		$this->base = $base;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:41: characters 3-21
		$this->nbits = $nbits;
	}


	/**
	 * @param Bytes $b
	 * 
	 * @return Bytes
	 */
	public function decodeBytes ($b) {
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:85: characters 3-26
		$nbits = $this->nbits;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:86: characters 3-24
		$base = $this->base;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:87: characters 3-37
		if ($this->tbl === null) {
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:87: characters 26-37
			$this->initTable();
		}
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:88: characters 3-22
		$tbl = $this->tbl;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:89: characters 3-38
		$size = ($b->length * $nbits) >> 3;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:90: characters 3-39
		$out = Bytes::alloc($size);
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:91: characters 3-15
		$buf = 0;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:92: characters 3-19
		$curbits = 0;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:93: characters 3-15
		$pin = 0;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:94: characters 3-16
		$pout = 0;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:95: lines 95-106
		while ($pout < $size) {
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:96: lines 96-103
			while ($curbits < 8) {
				#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:97: characters 5-21
				$curbits = $curbits + $nbits;
				#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:98: characters 5-18
				$buf = $buf << $nbits;
				#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:99: characters 23-28
				$pin = $pin + 1;
				#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:99: characters 5-31
				$i = ($tbl->arr[ord($b->b->s[$pin - 1])] ?? null);
				#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:100: lines 100-101
				if ($i === -1) {
					#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:101: characters 6-11
					throw new HxException("BaseCode : invalid encoded char");
				}
				#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:102: characters 5-13
				$buf = $buf | $i;
			}
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:104: characters 4-16
			$curbits = $curbits - 8;
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:105: characters 12-18
			$pout = $pout + 1;
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:105: characters 4-43
			$this1 = $out->b;
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:105: characters 4-43
			$this1->s = substr_replace($this1->s, chr(($buf >> $curbits) & 255), $pout - 1, 1);


		}
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:107: characters 3-13
		return $out;
	}


	/**
	 * @param string $s
	 * 
	 * @return string
	 */
	public function decodeString ($s) {
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:123: characters 22-47
		$s1 = strlen($s);
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:123: characters 3-59
		return $this->decodeBytes(new Bytes($s1, new Container($s)))->toString();
	}


	/**
	 * @param Bytes $b
	 * 
	 * @return Bytes
	 */
	public function encodeBytes ($b) {
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:48: characters 3-26
		$nbits = $this->nbits;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:49: characters 3-24
		$base = $this->base;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:50: characters 3-44
		$size = (int)($b->length * 8 / $nbits);
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:51: characters 3-82
		$out = Bytes::alloc($size + (((($b->length * 8) % $nbits) === 0 ? 0 : 1)));
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:52: characters 3-15
		$buf = 0;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:53: characters 3-19
		$curbits = 0;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:54: characters 3-31
		$mask = (1 << $nbits) - 1;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:55: characters 3-15
		$pin = 0;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:56: characters 3-16
		$pout = 0;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:57: lines 57-65
		while ($pout < $size) {
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:58: lines 58-62
			while ($curbits < $nbits) {
				#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:59: characters 5-17
				$curbits = $curbits + 8;
				#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:60: characters 5-14
				$buf = $buf << 8;
				#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:61: characters 18-23
				$pin = $pin + 1;
				#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:61: characters 5-24
				$buf = $buf | ord($b->b->s[$pin - 1]);
			}
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:63: characters 4-20
			$curbits = $curbits - $nbits;
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:64: characters 12-18
			$pout = $pout + 1;
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:64: characters 4-53
			$v = ord($base->b->s[($buf >> $curbits) & $mask]);
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:64: characters 4-53
			$this1 = $out->b;
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:64: characters 4-53
			$this1->s = substr_replace($this1->s, chr($v), $pout - 1, 1);


		}
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:66: lines 66-67
		if ($curbits > 0) {
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:67: characters 12-18
			$pout = $pout + 1;
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:67: characters 4-63
			$v1 = ord($base->b->s[($buf << ($nbits - $curbits)) & $mask]);
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:67: characters 4-63
			$this2 = $out->b;
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:67: characters 4-63
			$this2->s = substr_replace($this2->s, chr($v1), $pout - 1, 1);

		}
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:68: characters 3-13
		return $out;
	}


	/**
	 * @param string $s
	 * 
	 * @return string
	 */
	public function encodeString ($s) {
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:115: characters 22-47
		$s1 = strlen($s);
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:115: characters 3-59
		return $this->encodeBytes(new Bytes($s1, new Container($s)))->toString();
	}


	/**
	 * @return void
	 */
	public function initTable () {
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:73: characters 3-25
		$tbl = new \Array_hx();
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:74: lines 74-75
		$_g = 0;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:74: lines 74-75
		while ($_g < 256) {
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:74: lines 74-75
			$_g = $_g + 1;
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:74: characters 8-9
			$i = $_g - 1;
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:75: characters 4-15
			$tbl[$i] = -1;
		}

		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:76: lines 76-77
		$_g1 = 0;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:76: lines 76-77
		$_g2 = $this->base->length;
		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:76: lines 76-77
		while ($_g1 < $_g2) {
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:76: lines 76-77
			$_g1 = $_g1 + 1;
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:76: characters 8-9
			$i1 = $_g1 - 1;
			#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:77: characters 4-24
			$tbl[ord($this->base->b->s[$i1])] = $i1;
		}

		#/usr/local/lib/haxe/std/haxe/crypto/BaseCode.hx:78: characters 3-17
		$this->tbl = $tbl;
	}
}


Boot::registerClass(BaseCode::class, 'haxe.crypto.BaseCode');
