<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ da28365)
 * Haxe source file: /usr/local/lib/haxe/std/haxe/Int64.hx
 */

namespace haxe\_Int64;

use \php\Boot;
use \php\_Boot\HxException;
use \haxe\Int64Helper;
use \haxe\_Int32\Int32_Impl_;
use \php\_Boot\HxAnon;

final class Int64_Impl_ {


	/**
	 * @param ___Int64 $x
	 * 
	 * @return ___Int64
	 */
	static public function _new ($x) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:35: character 17
		$this1 = $x;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:35: character 17
		return $this1;
	}


	/**
	 * Returns the sum of `a` and `b`.
	 * 
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return ___Int64
	 */
	static public function add ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:254: characters 3-30
		$high = (($a->high + $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:255: characters 3-27
		$low = (($a->low + $b->low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:256: characters 3-48
		if (Int32_Impl_::ucompare($low, $a->low) < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:256: characters 42-48
			$high = $high + 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:256: characters 42-48
			$ret = $high - 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:256: characters 42-48
			$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:257: characters 10-27
		$this1 = new ___Int64($high, $low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:257: characters 10-27
		return $this1;
	}


	/**
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return ___Int64
	 */
	static public function addInt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:261: characters 18-19
		$this_high = $b >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:261: characters 18-19
		$this_low = $b;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:261: characters 10-21
		$high = (($a->high + $this_high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:261: characters 10-21
		$low = (($a->low + $this_low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:261: characters 10-21
		if (Int32_Impl_::ucompare($low, $a->low) < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:261: characters 10-21
			$high = $high + 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:261: characters 10-21
			$ret = $high - 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:256: characters 42-46
			$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:261: characters 10-21
		$this1 = new ___Int64($high, $low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:261: characters 10-21
		return $this1;
	}


	/**
	 * Returns the bitwise AND of `a` and `b`.
	 * 
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return ___Int64
	 */
	static public function and ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:393: characters 10-48
		$this1 = new ___Int64($a->high & $b->high, $a->low & $b->low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:393: characters 10-48
		return $this1;
	}


	/**
	 * Compares `a` and `b` in signed mode.
	 * Returns a negative value if `a < b`, positive if `a > b`,
	 * or 0 if `a == b`.
	 * 
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return int
	 */
	static public function compare ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:110: characters 3-27
		$v = (($a->high - $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:111: characters 20-21
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($a->low, $b->low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:112: characters 10-68
		if ($a->high < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:112: characters 23-44
			if ($b->high < 0) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:112: characters 37-38
				return $v;
			} else {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:112: characters 41-43
				return -1;
			}
		} else if ($b->high >= 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:112: characters 62-63
			return $v;
		} else {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:112: characters 66-67
			return 1;
		}
	}


	/**
	 * Returns the bitwise NOT of `a`.
	 * 
	 * @param ___Int64 $a
	 * 
	 * @return ___Int64
	 */
	static public function complement ($a) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:387: characters 10-33
		$this1 = new ___Int64((~$a->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, (~$a->low << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:387: characters 10-33
		return $this1;
	}


	/**
	 * Makes a copy of `this` Int64.
	 * 
	 * @param ___Int64 $this
	 * 
	 * @return ___Int64
	 */
	static public function copy ($this1) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:42: characters 10-27
		$this2 = new ___Int64($this1->high, $this1->low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:42: characters 10-27
		return $this2;
	}


	/**
	 * Returns the quotient of `a` divided by `b`.
	 * 
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return ___Int64
	 */
	static public function div ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:309: characters 3-31
		return Int64_Impl_::divMod($a, $b)->quotient;
	}


	/**
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return ___Int64
	 */
	static public function divInt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:312: characters 18-19
		$this1 = new ___Int64($b >> 31, $b);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:312: characters 10-21
		return Int64_Impl_::divMod($a, $this1)->quotient;
	}


	/**
	 * Performs signed integer divison of `dividend` by `divisor`.
	 * Returns `{ quotient : Int64, modulus : Int64 }`.
	 * 
	 * @param ___Int64 $dividend
	 * @param ___Int64 $divisor
	 * 
	 * @return object
	 */
	static public function divMod ($dividend, $divisor) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:172: lines 172-178
		if ($divisor->high === 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:174: characters 12-23
			$_g = $divisor->low;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:174: characters 12-23
			switch ($_g) {
				case 0:
					#/usr/local/lib/haxe/std/haxe/Int64.hx:175: characters 13-18
					throw new HxException("divide by zero");
					break;
				case 1:
					#/usr/local/lib/haxe/std/haxe/Int64.hx:176: characters 33-48
					$this1 = new ___Int64($dividend->high, $dividend->low);
					#/usr/local/lib/haxe/std/haxe/Int64.hx:176: characters 60-61
					$this2 = new ___Int64(0, 0);
					#/usr/local/lib/haxe/std/haxe/Int64.hx:176: characters 13-63
					return new HxAnon([
						"quotient" => $this1,
						"modulus" => $this2,
					]);
					break;
			}
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:180: characters 3-53
		$divSign = ($dividend->high < 0) !== ($divisor->high < 0);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:182: characters 3-64
		$modulus = null;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:182: characters 17-63
		if ($dividend->high < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:182: characters 36-45
			$high = (~$dividend->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:182: characters 36-45
			$low = -$dividend->low;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:182: characters 36-45
			if ($low === 0) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:182: characters 36-45
				$high = $high + 1;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:182: characters 36-45
				$ret = $high - 1;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:220: characters 4-8
				$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			}
			#/usr/local/lib/haxe/std/haxe/Int64.hx:182: characters 36-45
			$this3 = new ___Int64($high, $low);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:182: characters 3-64
			$modulus = $this3;
		} else {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:182: characters 48-63
			$this4 = new ___Int64($dividend->high, $dividend->low);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:182: characters 3-64
			$modulus = $this4;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:183: characters 13-49
		if ($divisor->high < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:183: characters 31-39
			$high1 = (~$divisor->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:183: characters 31-39
			$low1 = -$divisor->low;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:183: characters 31-39
			if ($low1 === 0) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:183: characters 31-39
				$high1 = $high1 + 1;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:183: characters 31-39
				$ret1 = $high1 - 1;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:220: characters 4-8
				$high1 = ($high1 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			}
			#/usr/local/lib/haxe/std/haxe/Int64.hx:183: characters 31-39
			$this5 = new ___Int64($high1, $low1);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:183: characters 31-39
			$divisor = $this5;
		} else {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:183: characters 42-49
			$divisor = $divisor;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:185: characters 3-28
		$this6 = new ___Int64(0, 0);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:185: characters 3-28
		$quotient = $this6;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:186: characters 3-24
		$this7 = new ___Int64(0, 1);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:186: characters 3-24
		$mask = $this7;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:188: lines 188-193
		while (!($divisor->high < 0)) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:189: characters 14-42
			$v = Int32_Impl_::ucompare($divisor->high, $modulus->high);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:189: characters 4-43
			$cmp = ($v !== 0 ? $v : Int32_Impl_::ucompare($divisor->low, $modulus->low));
			#/usr/local/lib/haxe/std/haxe/Int64.hx:190: characters 4-17
			$b = 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:190: characters 4-17
			$b = $b & 63;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:190: characters 4-17
			if ($b === 0) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:190: characters 4-17
				$this8 = new ___Int64($divisor->high, $divisor->low);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:190: characters 4-17
				$divisor = $this8;
			} else if ($b < 32) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:190: characters 4-17
				$this9 = new ___Int64((((($divisor->high << $b << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) | Boot::shiftRightUnsigned($divisor->low, (32 - $b))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, ($divisor->low << $b << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:190: characters 4-17
				$divisor = $this9;
			} else {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:190: characters 4-17
				$this10 = new ___Int64(($divisor->low << ($b - 32) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, 0);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:190: characters 4-17
				$divisor = $this10;
			}
			#/usr/local/lib/haxe/std/haxe/Int64.hx:191: characters 4-14
			$b1 = 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:191: characters 4-14
			$b1 = $b1 & 63;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:191: characters 4-14
			if ($b1 === 0) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:191: characters 4-14
				$this11 = new ___Int64($mask->high, $mask->low);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:191: characters 4-14
				$mask = $this11;
			} else if ($b1 < 32) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:191: characters 4-14
				$this12 = new ___Int64((((($mask->high << $b1 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) | Boot::shiftRightUnsigned($mask->low, (32 - $b1))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, ($mask->low << $b1 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:191: characters 4-14
				$mask = $this12;
			} else {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:191: characters 4-14
				$this13 = new ___Int64(($mask->low << ($b1 - 32) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, 0);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:191: characters 4-14
				$mask = $this13;
			}
			#/usr/local/lib/haxe/std/haxe/Int64.hx:192: characters 4-24
			if ($cmp >= 0) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:192: characters 19-24
				break;
			}
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:195: lines 195-202
		while (true) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:195: characters 10-19
			$this_high = 0;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:195: characters 10-19
			$this_low = 0;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:195: lines 195-202
			if (!(($mask->high !== $this_high) || ($mask->low !== $this_low))) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:195: lines 195-202
				break;
			}
			#/usr/local/lib/haxe/std/haxe/Int64.hx:196: characters 8-34
			$v1 = Int32_Impl_::ucompare($modulus->high, $divisor->high);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:196: lines 196-199
			if ((($v1 !== 0 ? $v1 : Int32_Impl_::ucompare($modulus->low, $divisor->low))) >= 0) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:197: characters 5-21
				$this14 = new ___Int64((($quotient->high | $mask->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, (($quotient->low | $mask->low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:197: characters 5-21
				$quotient = $this14;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:198: characters 5-23
				$high2 = (($modulus->high - $divisor->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:198: characters 5-23
				$low2 = (($modulus->low - $divisor->low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:198: characters 5-23
				if (Int32_Impl_::ucompare($modulus->low, $divisor->low) < 0) {
					#/usr/local/lib/haxe/std/haxe/Int64.hx:198: characters 5-23
					$high2 = $high2 - 1;
					#/usr/local/lib/haxe/std/haxe/Int64.hx:198: characters 5-23
					$ret2 = $high2 + 1;
					#/usr/local/lib/haxe/std/haxe/Int64.hx:269: characters 44-48
					$high2 = ($high2 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				}
				#/usr/local/lib/haxe/std/haxe/Int64.hx:198: characters 5-23
				$this15 = new ___Int64($high2, $low2);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:198: characters 5-23
				$modulus = $this15;
			}
			#/usr/local/lib/haxe/std/haxe/Int64.hx:200: characters 4-15
			$b2 = 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:200: characters 4-15
			$b2 = $b2 & 63;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:200: characters 4-15
			if ($b2 === 0) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:200: characters 4-15
				$this16 = new ___Int64($mask->high, $mask->low);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:200: characters 4-15
				$mask = $this16;
			} else if ($b2 < 32) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:200: characters 4-15
				$this17 = new ___Int64(Boot::shiftRightUnsigned($mask->high, $b2), (((($mask->high << (32 - $b2) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) | Boot::shiftRightUnsigned($mask->low, $b2)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:200: characters 4-15
				$mask = $this17;
			} else {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:200: characters 4-15
				$this18 = new ___Int64(0, Boot::shiftRightUnsigned($mask->high, ($b2 - 32)));
				#/usr/local/lib/haxe/std/haxe/Int64.hx:200: characters 4-15
				$mask = $this18;
			}
			#/usr/local/lib/haxe/std/haxe/Int64.hx:201: characters 4-18
			$b3 = 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:201: characters 4-18
			$b3 = $b3 & 63;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:201: characters 4-18
			if ($b3 === 0) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:201: characters 4-18
				$this19 = new ___Int64($divisor->high, $divisor->low);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:201: characters 4-18
				$divisor = $this19;
			} else if ($b3 < 32) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:201: characters 4-18
				$this20 = new ___Int64(Boot::shiftRightUnsigned($divisor->high, $b3), (((($divisor->high << (32 - $b3) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) | Boot::shiftRightUnsigned($divisor->low, $b3)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:201: characters 4-18
				$divisor = $this20;
			} else {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:201: characters 4-18
				$this21 = new ___Int64(0, Boot::shiftRightUnsigned($divisor->high, ($b3 - 32)));
				#/usr/local/lib/haxe/std/haxe/Int64.hx:201: characters 4-18
				$divisor = $this21;
			}
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:204: characters 3-37
		if ($divSign) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:204: characters 28-37
			$high3 = (~$quotient->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:204: characters 28-37
			$low3 = -$quotient->low;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:204: characters 28-37
			if ($low3 === 0) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:204: characters 28-37
				$high3 = $high3 + 1;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:204: characters 28-37
				$ret3 = $high3 - 1;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:220: characters 4-8
				$high3 = ($high3 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			}
			#/usr/local/lib/haxe/std/haxe/Int64.hx:204: characters 28-37
			$this22 = new ___Int64($high3, $low3);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:204: characters 28-37
			$quotient = $this22;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:205: characters 3-44
		if ($dividend->high < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:205: characters 36-44
			$high4 = (~$modulus->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:205: characters 36-44
			$low4 = -$modulus->low;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:205: characters 36-44
			if ($low4 === 0) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:205: characters 36-44
				$high4 = $high4 + 1;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:205: characters 36-44
				$ret4 = $high4 - 1;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:220: characters 4-8
				$high4 = ($high4 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
			}
			#/usr/local/lib/haxe/std/haxe/Int64.hx:205: characters 36-44
			$this23 = new ___Int64($high4, $low4);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:205: characters 36-44
			$modulus = $this23;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:207: lines 207-210
		return new HxAnon([
			"quotient" => $quotient,
			"modulus" => $modulus,
		]);
	}


	/**
	 * Returns `true` if `a` is equal to `b`.
	 * 
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return bool
	 */
	static public function eq ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:333: characters 10-44
		if ($a->high === $b->high) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:333: characters 30-44
			return $a->low === $b->low;
		} else {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:333: characters 10-44
			return false;
		}
	}


	/**
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return bool
	 */
	static public function eqInt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:336: characters 17-18
		$this_high = $b >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:336: characters 17-18
		$this_low = $b;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:336: characters 10-20
		if ($a->high === $this_high) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:336: characters 10-20
			return $a->low === $this_low;
		} else {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:336: characters 10-20
			return false;
		}
	}


	/**
	 * @param float $f
	 * 
	 * @return ___Int64
	 */
	static public function fromFloat ($f) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:162: characters 3-36
		return Int64Helper::fromFloat($f);
	}


	/**
	 * Returns the high 32-bit word of `x`.
	 * 
	 * @param ___Int64 $x
	 * 
	 * @return int
	 */
	static public function getHigh ($x) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:83: characters 3-16
		return $x->high;
	}


	/**
	 * Returns the low 32-bit word of `x`.
	 * 
	 * @param ___Int64 $x
	 * 
	 * @return int
	 */
	static public function getLow ($x) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:90: characters 3-15
		return $x->low;
	}


	/**
	 * @param ___Int64 $this
	 * 
	 * @return int
	 */
	static public function get_high ($this1) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:440: characters 37-53
		return $this1->high;
	}


	/**
	 * @param ___Int64 $this
	 * 
	 * @return int
	 */
	static public function get_low ($this1) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:444: characters 36-51
		return $this1->low;
	}


	/**
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return bool
	 */
	static public function gt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:366: characters 10-23
		$v = (($a->high - $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:366: characters 10-23
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($a->low, $b->low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:366: characters 3-27
		return (($a->high < 0 ? ($b->high < 0 ? $v : -1) : ($b->high >= 0 ? $v : 1))) > 0;
	}


	/**
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return bool
	 */
	static public function gtInt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:369: characters 16-17
		$this_high = $b >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:369: characters 16-17
		$this_low = $b;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:369: characters 10-18
		$v = (($a->high - $this_high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:369: characters 10-18
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($a->low, $this_low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:369: characters 10-18
		return (($a->high < 0 ? ($this_high < 0 ? $v : -1) : ($this_high >= 0 ? $v : 1))) > 0;
	}


	/**
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return bool
	 */
	static public function gte ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:375: characters 10-23
		$v = (($a->high - $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:375: characters 10-23
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($a->low, $b->low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:375: characters 3-28
		return (($a->high < 0 ? ($b->high < 0 ? $v : -1) : ($b->high >= 0 ? $v : 1))) >= 0;
	}


	/**
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return bool
	 */
	static public function gteInt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:378: characters 17-18
		$this_high = $b >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:378: characters 17-18
		$this_low = $b;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:378: characters 10-19
		$v = (($a->high - $this_high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:378: characters 10-19
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($a->low, $this_low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:378: characters 10-19
		return (($a->high < 0 ? ($this_high < 0 ? $v : -1) : ($this_high >= 0 ? $v : 1))) >= 0;
	}


	/**
	 * @param int $a
	 * @param ___Int64 $b
	 * 
	 * @return ___Int64
	 */
	static public function intDiv ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:315: characters 15-16
		$this1 = new ___Int64($a >> 31, $a);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:315: characters 10-29
		$x = Int64_Impl_::divMod($this1, $b)->quotient;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:315: characters 10-29
		if ($x->high !== ((($x->low >> 31) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits)) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:315: characters 10-29
			throw new HxException("Overflow");
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:315: characters 3-29
		$x1 = $x->low;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:315: characters 3-29
		$this2 = new ___Int64($x1 >> 31, $x1);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:315: characters 3-29
		return $this2;
	}


	/**
	 * @param int $a
	 * @param ___Int64 $b
	 * 
	 * @return bool
	 */
	static public function intGt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:372: characters 14-15
		$this_high = $a >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:372: characters 14-15
		$this_low = $a;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:372: characters 10-20
		$v = (($this_high - $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:372: characters 10-20
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($this_low, $b->low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:372: characters 10-20
		return (($this_high < 0 ? ($b->high < 0 ? $v : -1) : ($b->high >= 0 ? $v : 1))) > 0;
	}


	/**
	 * @param int $a
	 * @param ___Int64 $b
	 * 
	 * @return bool
	 */
	static public function intGte ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:381: characters 14-15
		$this_high = $a >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:381: characters 14-15
		$this_low = $a;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:381: characters 10-19
		$v = (($this_high - $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:381: characters 10-19
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($this_low, $b->low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:381: characters 10-19
		return (($this_high < 0 ? ($b->high < 0 ? $v : -1) : ($b->high >= 0 ? $v : 1))) >= 0;
	}


	/**
	 * @param int $a
	 * @param ___Int64 $b
	 * 
	 * @return bool
	 */
	static public function intLt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:354: characters 13-14
		$this_high = $a >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:354: characters 13-14
		$this_low = $a;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:354: characters 10-18
		$v = (($this_high - $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:354: characters 10-18
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($this_low, $b->low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:354: characters 10-18
		return (($this_high < 0 ? ($b->high < 0 ? $v : -1) : ($b->high >= 0 ? $v : 1))) < 0;
	}


	/**
	 * @param int $a
	 * @param ___Int64 $b
	 * 
	 * @return bool
	 */
	static public function intLte ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:363: characters 14-15
		$this_high = $a >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:363: characters 14-15
		$this_low = $a;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:363: characters 10-19
		$v = (($this_high - $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:363: characters 10-19
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($this_low, $b->low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:363: characters 10-19
		return (($this_high < 0 ? ($b->high < 0 ? $v : -1) : ($b->high >= 0 ? $v : 1))) <= 0;
	}


	/**
	 * @param int $a
	 * @param ___Int64 $b
	 * 
	 * @return ___Int64
	 */
	static public function intMod ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:327: characters 15-16
		$this1 = new ___Int64($a >> 31, $a);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:327: characters 10-29
		$x = Int64_Impl_::divMod($this1, $b)->modulus;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:327: characters 10-29
		if ($x->high !== ((($x->low >> 31) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits)) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:327: characters 10-29
			throw new HxException("Overflow");
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:327: characters 3-29
		$x1 = $x->low;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:327: characters 3-29
		$this2 = new ___Int64($x1 >> 31, $x1);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:327: characters 3-29
		return $this2;
	}


	/**
	 * @param int $a
	 * @param ___Int64 $b
	 * 
	 * @return ___Int64
	 */
	static public function intSub ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:277: characters 15-16
		$this_high = $a >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:277: characters 15-16
		$this_low = $a;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:277: characters 10-21
		$high = (($this_high - $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:277: characters 10-21
		$low = (($this_low - $b->low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:277: characters 10-21
		if (Int32_Impl_::ucompare($this_low, $b->low) < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:277: characters 10-21
			$high = $high - 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:277: characters 10-21
			$ret = $high + 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:269: characters 44-48
			$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:277: characters 10-21
		$this1 = new ___Int64($high, $low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:277: characters 10-21
		return $this1;
	}


	/**
	 * Returns whether the value `val` is of type `haxe.Int64`
	 * 
	 * @param mixed $val
	 * 
	 * @return bool
	 */
	static public function is ($val) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:76: characters 3-29
		return ($val instanceof ___Int64);
	}


	/**
	 * Returns `true` if `x` is less than zero.
	 * 
	 * @param ___Int64 $x
	 * 
	 * @return bool
	 */
	static public function isNeg ($x) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:96: characters 3-20
		return $x->high < 0;
	}


	/**
	 * Returns `true` if `x` is exactly zero.
	 * 
	 * @param ___Int64 $x
	 * 
	 * @return bool
	 */
	static public function isZero ($x) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:102: characters 10-16
		$this_high = 0;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:102: characters 10-16
		$this_low = 0;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:102: characters 10-16
		if ($x->high === $this_high) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:102: characters 10-16
			return $x->low === $this_low;
		} else {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:102: characters 10-16
			return false;
		}
	}


	/**
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return bool
	 */
	static public function lt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:348: characters 10-23
		$v = (($a->high - $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:348: characters 10-23
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($a->low, $b->low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:348: characters 3-27
		return (($a->high < 0 ? ($b->high < 0 ? $v : -1) : ($b->high >= 0 ? $v : 1))) < 0;
	}


	/**
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return bool
	 */
	static public function ltInt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:351: characters 16-17
		$this_high = $b >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:351: characters 16-17
		$this_low = $b;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:351: characters 10-18
		$v = (($a->high - $this_high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:351: characters 10-18
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($a->low, $this_low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:351: characters 10-18
		return (($a->high < 0 ? ($this_high < 0 ? $v : -1) : ($this_high >= 0 ? $v : 1))) < 0;
	}


	/**
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return bool
	 */
	static public function lte ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:357: characters 10-23
		$v = (($a->high - $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:357: characters 10-23
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($a->low, $b->low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:357: characters 3-28
		return (($a->high < 0 ? ($b->high < 0 ? $v : -1) : ($b->high >= 0 ? $v : 1))) <= 0;
	}


	/**
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return bool
	 */
	static public function lteInt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:360: characters 17-18
		$this_high = $b >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:360: characters 17-18
		$this_low = $b;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:360: characters 10-19
		$v = (($a->high - $this_high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:360: characters 10-19
		$v = ($v !== 0 ? $v : Int32_Impl_::ucompare($a->low, $this_low));
		#/usr/local/lib/haxe/std/haxe/Int64.hx:360: characters 10-19
		return (($a->high < 0 ? ($this_high < 0 ? $v : -1) : ($this_high >= 0 ? $v : 1))) <= 0;
	}


	/**
	 * Construct an Int64 from two 32-bit words `high` and `low`.
	 * 
	 * @param int $high
	 * @param int $low
	 * 
	 * @return ___Int64
	 */
	static public function make ($high, $low) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:48: characters 10-45
		$this1 = new ___Int64($high, $low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:48: characters 10-45
		return $this1;
	}


	/**
	 * Returns the modulus of `a` divided by `b`.
	 * 
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return ___Int64
	 */
	static public function mod ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:321: characters 3-30
		return Int64_Impl_::divMod($a, $b)->modulus;
	}


	/**
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return ___Int64
	 */
	static public function modInt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:324: characters 18-19
		$this1 = new ___Int64($b >> 31, $b);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:324: characters 10-29
		$x = Int64_Impl_::divMod($a, $this1)->modulus;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:324: characters 10-29
		if ($x->high !== ((($x->low >> 31) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits)) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:324: characters 10-29
			throw new HxException("Overflow");
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:324: characters 3-29
		$x1 = $x->low;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:324: characters 3-29
		$this2 = new ___Int64($x1 >> 31, $x1);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:324: characters 3-29
		return $this2;
	}


	/**
	 * Returns the product of `a` and `b`.
	 * 
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return ___Int64
	 */
	static public function mul ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:283: characters 3-21
		$mask = 65535;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:284: characters 3-44
		$al = $a->low & $mask;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:284: characters 3-44
		$ah = Boot::shiftRightUnsigned($a->low, 16);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:285: characters 3-44
		$bl = $b->low & $mask;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:285: characters 3-44
		$bh = Boot::shiftRightUnsigned($b->low, 16);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:286: characters 3-21
		$p00 = Int32_Impl_::mul($al, $bl);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:287: characters 3-21
		$p10 = Int32_Impl_::mul($ah, $bl);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:288: characters 3-21
		$p01 = Int32_Impl_::mul($al, $bh);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:289: characters 3-21
		$p11 = Int32_Impl_::mul($ah, $bh);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:290: characters 3-17
		$low = $p00;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:291: characters 3-48
		$high = ((((($p11 + (Boot::shiftRightUnsigned($p01, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) + (Boot::shiftRightUnsigned($p10, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:292: characters 3-13
		$p01 = ($p01 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:293: characters 3-13
		$low = (($low + $p01) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:294: characters 3-44
		if (Int32_Impl_::ucompare($low, $p01) < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:294: characters 38-44
			$high = $high + 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:294: characters 38-44
			$ret = $high - 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:294: characters 38-44
			$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:295: characters 3-13
		$p10 = ($p10 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:296: characters 3-13
		$low = (($low + $p10) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:297: characters 3-44
		if (Int32_Impl_::ucompare($low, $p10) < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:297: characters 38-44
			$high = $high + 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:297: characters 38-44
			$ret1 = $high - 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:297: characters 38-44
			$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:298: characters 3-42
		$high = (($high + (((Int32_Impl_::mul($a->low, $b->high) + Int32_Impl_::mul($a->high, $b->low)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:299: characters 10-27
		$this1 = new ___Int64($high, $low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:299: characters 10-27
		return $this1;
	}


	/**
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return ___Int64
	 */
	static public function mulInt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 18-19
		$this_high = $b >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 18-19
		$this_low = $b;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$mask = 65535;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$al = $a->low & $mask;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$ah = Boot::shiftRightUnsigned($a->low, 16);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$bl = $this_low & $mask;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$bh = Boot::shiftRightUnsigned($this_low, 16);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$p00 = Int32_Impl_::mul($al, $bl);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$p10 = Int32_Impl_::mul($ah, $bl);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$p01 = Int32_Impl_::mul($al, $bh);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$p11 = Int32_Impl_::mul($ah, $bh);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$low = $p00;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$high = ((((($p11 + (Boot::shiftRightUnsigned($p01, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) + (Boot::shiftRightUnsigned($p10, 16))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:292: characters 3-6
		$p01 = ($p01 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:293: characters 3-6
		$low = (($low + $p01) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		if (Int32_Impl_::ucompare($low, $p01) < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
			$high = $high + 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
			$ret = $high - 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:294: characters 38-42
			$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:295: characters 3-6
		$p10 = ($p10 << 16 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:296: characters 3-6
		$low = (($low + $p10) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		if (Int32_Impl_::ucompare($low, $p10) < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
			$high = $high + 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
			$ret1 = $high - 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:297: characters 38-42
			$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$high = (($high + (((Int32_Impl_::mul($a->low, $this_high) + Int32_Impl_::mul($a->high, $this_low)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		$this1 = new ___Int64($high, $low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:303: characters 10-21
		return $this1;
	}


	/**
	 * Returns the negative of `x`.
	 * 
	 * @param ___Int64 $x
	 * 
	 * @return ___Int64
	 */
	static public function neg ($x) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:217: characters 3-22
		$high = (~$x->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:218: characters 3-20
		$low = -$x->low;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:219: lines 219-220
		if ($low === 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:220: characters 4-10
			$high = $high + 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:220: characters 4-10
			$ret = $high - 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:220: characters 4-10
			$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:221: characters 10-27
		$this1 = new ___Int64($high, $low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:221: characters 10-27
		return $this1;
	}


	/**
	 * Returns `true` if `a` is not equal to `b`.
	 * 
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return bool
	 */
	static public function neq ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:342: characters 10-44
		if (!($a->high !== $b->high)) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:342: characters 30-44
			return $a->low !== $b->low;
		} else {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:342: characters 10-44
			return true;
		}
	}


	/**
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return bool
	 */
	static public function neqInt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:345: characters 17-18
		$this_high = $b >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:345: characters 17-18
		$this_low = $b;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:345: characters 10-19
		if (!($a->high !== $this_high)) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:345: characters 10-19
			return $a->low !== $this_low;
		} else {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:345: characters 10-19
			return true;
		}
	}


	/**
	 * Returns an Int64 with the value of the Int `x`.
	 * `x` is sign-extended to fill 64 bits.
	 * 
	 * @param int $x
	 * 
	 * @return ___Int64
	 */
	static public function ofInt ($x) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:58: characters 10-28
		$this1 = new ___Int64($x >> 31, $x);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:58: characters 10-28
		return $this1;
	}


	/**
	 * Returns the bitwise OR of `a` and `b`.
	 * 
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return ___Int64
	 */
	static public function or ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:399: characters 10-48
		$this1 = new ___Int64((($a->high | $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, (($a->low | $b->low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:399: characters 10-48
		return $this1;
	}


	/**
	 * @param string $sParam
	 * 
	 * @return ___Int64
	 */
	static public function parseString ($sParam) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:158: characters 3-43
		return Int64Helper::parseString($sParam);
	}


	/**
	 * @param ___Int64 $this
	 * 
	 * @return ___Int64
	 */
	static public function postDecrement ($this1) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:245: characters 3-18
		$ret = $this1;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:246: characters 3-17
		$this2 = new ___Int64($this1->high, $this1->low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:246: characters 3-17
		$this1 = $this2;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:246: characters 3-17
		if ($this1->low === 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:246: characters 3-17
			$ret1 = $this1->high--;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:246: characters 3-17
			$this1->high = ($this1->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:246: characters 3-17
		$ret2 = $this1->low--;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:246: characters 3-17
		$this1->low = ($this1->low << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;


		#/usr/local/lib/haxe/std/haxe/Int64.hx:247: characters 3-13
		return $ret;
	}


	/**
	 * @param ___Int64 $this
	 * 
	 * @return ___Int64
	 */
	static public function postIncrement ($this1) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:232: characters 3-18
		$ret = $this1;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:233: characters 3-17
		$this2 = new ___Int64($this1->high, $this1->low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:233: characters 3-17
		$this1 = $this2;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:233: characters 3-17
		$ret1 = $this1->low++;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:233: characters 3-17
		$this1->low = ($this1->low << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;

		#/usr/local/lib/haxe/std/haxe/Int64.hx:233: characters 3-17
		if ($this1->low === 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:233: characters 3-17
			$ret2 = $this1->high++;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:233: characters 3-17
			$this1->high = ($this1->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}

		#/usr/local/lib/haxe/std/haxe/Int64.hx:234: characters 3-13
		return $ret;
	}


	/**
	 * @param ___Int64 $this
	 * 
	 * @return ___Int64
	 */
	static public function preDecrement ($this1) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:238: characters 10-16
		$this2 = new ___Int64($this1->high, $this1->low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:238: characters 10-16
		$this1 = $this2;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:239: characters 3-34
		if ($this1->low === 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:239: characters 23-34
			$ret = $this1->high--;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:239: characters 23-34
			$this1->high = ($this1->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:240: characters 3-13
		$ret1 = $this1->low--;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:240: characters 3-13
		$this1->low = ($this1->low << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;

		#/usr/local/lib/haxe/std/haxe/Int64.hx:241: characters 3-19
		return $this1;
	}


	/**
	 * @param ___Int64 $this
	 * 
	 * @return ___Int64
	 */
	static public function preIncrement ($this1) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:225: characters 10-16
		$this2 = new ___Int64($this1->high, $this1->low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:225: characters 10-16
		$this1 = $this2;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:226: characters 3-13
		$ret = $this1->low++;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:226: characters 3-13
		$this1->low = ($this1->low << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;

		#/usr/local/lib/haxe/std/haxe/Int64.hx:227: characters 3-34
		if ($this1->low === 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:227: characters 23-34
			$ret1 = $this1->high++;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:227: characters 23-34
			$this1->high = ($this1->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:228: characters 3-19
		return $this1;
	}


	/**
	 * @param ___Int64 $this
	 * @param int $x
	 * 
	 * @return int
	 */
	static public function set_high ($this1, $x) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:441: characters 38-58
		return $this1->high = $x;
	}


	/**
	 * @param ___Int64 $this
	 * @param int $x
	 * 
	 * @return int
	 */
	static public function set_low ($this1, $x) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:445: characters 37-56
		return $this1->low = $x;
	}


	/**
	 * Returns `a` left-shifted by `b` bits.
	 * 
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return ___Int64
	 */
	static public function shl ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:411: characters 3-10
		$b = $b & 63;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:412: lines 412-414
		if ($b === 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:412: characters 23-31
			$this1 = new ___Int64($a->high, $a->low);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:412: characters 23-31
			return $this1;
		} else if ($b < 32) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:413: characters 22-75
			$this2 = new ___Int64((((($a->high << $b << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) | Boot::shiftRightUnsigned($a->low, (32 - $b))) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, ($a->low << $b << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:413: characters 22-75
			return $this2;
		} else {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:414: characters 9-35
			$this3 = new ___Int64(($a->low << ($b - 32) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, 0);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:414: characters 9-35
			return $this3;
		}
	}


	/**
	 * Returns `a` right-shifted by `b` bits in signed mode.
	 * `a` is sign-extended.
	 * 
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return ___Int64
	 */
	static public function shr ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:422: characters 3-10
		$b = $b & 63;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:423: lines 423-425
		if ($b === 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:423: characters 23-31
			$this1 = new ___Int64($a->high, $a->low);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:423: characters 23-31
			return $this1;
		} else if ($b < 32) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:424: characters 22-77
			$this2 = new ___Int64((($a->high >> $b) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, (((($a->high << (32 - $b) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) | Boot::shiftRightUnsigned($a->low, $b)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:424: characters 22-77
			return $this2;
		} else {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:425: characters 9-49
			$this3 = new ___Int64((($a->high >> 31) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, (($a->high >> ($b - 32)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:425: characters 9-49
			return $this3;
		}
	}


	/**
	 * Returns `a` minus `b`.
	 * 
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return ___Int64
	 */
	static public function sub ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:267: characters 3-30
		$high = (($a->high - $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:268: characters 3-27
		$low = (($a->low - $b->low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:269: characters 3-50
		if (Int32_Impl_::ucompare($a->low, $b->low) < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:269: characters 44-50
			$high = $high - 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:269: characters 44-50
			$ret = $high + 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:269: characters 44-50
			$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:270: characters 16-33
		$this1 = new ___Int64($high, $low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:270: characters 16-33
		return $this1;
	}


	/**
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return ___Int64
	 */
	static public function subInt ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:274: characters 18-19
		$this_high = $b >> 31;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:274: characters 18-19
		$this_low = $b;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:274: characters 10-21
		$high = (($a->high - $this_high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:274: characters 10-21
		$low = (($a->low - $this_low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:274: characters 10-21
		if (Int32_Impl_::ucompare($a->low, $this_low) < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:274: characters 10-21
			$high = $high - 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:274: characters 10-21
			$ret = $high + 1;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:269: characters 44-48
			$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:274: characters 10-21
		$this1 = new ___Int64($high, $low);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:274: characters 10-21
		return $this1;
	}


	/**
	 * Returns an Int with the value of the Int64 `x`.
	 * Throws an exception  if `x` cannot be represented in 32 bits.
	 * 
	 * @param ___Int64 $x
	 * 
	 * @return int
	 */
	static public function toInt ($x) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:66: lines 66-67
		if ($x->high !== ((($x->low >> 31) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits)) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:67: characters 4-9
			throw new HxException("Overflow");
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:69: characters 3-15
		return $x->low;
	}


	/**
	 * Returns a signed decimal `String` representation of `x`.
	 * 
	 * @param ___Int64 $x
	 * 
	 * @return string
	 */
	static public function toStr ($x) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:129: characters 3-22
		return Int64_Impl_::toString($x);
	}


	/**
	 * @param ___Int64 $this
	 * 
	 * @return string
	 */
	static public function toString ($this1) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:133: characters 3-29
		$i = $this1;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:134: characters 8-14
		$this_high = 0;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:134: characters 8-14
		$this_low = 0;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:134: lines 134-135
		if (($i->high === $this_high) && ($i->low === $this_low)) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:135: characters 4-14
			return "0";
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:136: characters 3-16
		$str = "";
		#/usr/local/lib/haxe/std/haxe/Int64.hx:137: characters 3-19
		$neg = false;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:138: lines 138-141
		if ($i->high < 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:139: characters 4-7
			$neg = true;
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:142: characters 3-24
		$this2 = new ___Int64(0, 10);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:142: characters 3-24
		$ten = $this2;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:143: lines 143-152
		while (true) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:143: characters 10-16
			$this_high1 = 0;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:143: characters 10-16
			$this_low1 = 0;
			#/usr/local/lib/haxe/std/haxe/Int64.hx:143: lines 143-152
			if (!(($i->high !== $this_high1) || ($i->low !== $this_low1))) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:143: lines 143-152
				break;
			}
			#/usr/local/lib/haxe/std/haxe/Int64.hx:144: characters 4-28
			$r = Int64_Impl_::divMod($i, $ten);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:145: lines 145-151
			if ($r->modulus->high < 0) {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:146: characters 11-31
				$x = $r->modulus;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:146: characters 11-31
				$high = (~$x->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:146: characters 11-31
				$low = -$x->low;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:146: characters 11-31
				if ($low === 0) {
					#/usr/local/lib/haxe/std/haxe/Int64.hx:146: characters 11-31
					$high = $high + 1;
					#/usr/local/lib/haxe/std/haxe/Int64.hx:146: characters 11-31
					$ret = $high - 1;
					#/usr/local/lib/haxe/std/haxe/Int64.hx:220: characters 4-8
					$high = ($high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				}
				#/usr/local/lib/haxe/std/haxe/Int64.hx:146: characters 11-31
				$this_high2 = $high;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:146: characters 11-31
				$this_low2 = $low;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:146: characters 5-8
				$str = ($this_low2??'null') . ($str??'null');
				#/usr/local/lib/haxe/std/haxe/Int64.hx:147: characters 9-30
				$x1 = $r->quotient;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:147: characters 9-30
				$high1 = (~$x1->high << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:147: characters 9-30
				$low1 = -$x1->low;
				#/usr/local/lib/haxe/std/haxe/Int64.hx:147: characters 9-30
				if ($low1 === 0) {
					#/usr/local/lib/haxe/std/haxe/Int64.hx:147: characters 9-30
					$high1 = $high1 + 1;
					#/usr/local/lib/haxe/std/haxe/Int64.hx:147: characters 9-30
					$ret1 = $high1 - 1;
					#/usr/local/lib/haxe/std/haxe/Int64.hx:220: characters 4-8
					$high1 = ($high1 << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits;
				}
				#/usr/local/lib/haxe/std/haxe/Int64.hx:147: characters 9-30
				$this3 = new ___Int64($high1, $low1);
				#/usr/local/lib/haxe/std/haxe/Int64.hx:147: characters 9-30
				$i = $this3;
			} else {
				#/usr/local/lib/haxe/std/haxe/Int64.hx:149: characters 5-8
				$str = ($r->modulus->low??'null') . ($str??'null');
				#/usr/local/lib/haxe/std/haxe/Int64.hx:150: characters 5-6
				$i = $r->quotient;
			}
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:153: characters 3-28
		if ($neg) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:153: characters 13-16
			$str = "-" . ($str??'null');
		}
		#/usr/local/lib/haxe/std/haxe/Int64.hx:154: characters 3-13
		return $str;
	}


	/**
	 * Compares `a` and `b` in unsigned mode.
	 * Returns a negative value if `a < b`, positive if `a > b`,
	 * or 0 if `a == b`.
	 * 
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return int
	 */
	static public function ucompare ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:121: characters 3-42
		$v = Int32_Impl_::ucompare($a->high, $b->high);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:122: characters 10-58
		if ($v !== 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:122: characters 23-24
			return $v;
		} else {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:122: characters 30-58
			return Int32_Impl_::ucompare($a->low, $b->low);
		}
	}


	/**
	 * Returns `a` right-shifted by `b` bits in unsigned mode.
	 * `a` is padded with zeroes.
	 * 
	 * @param ___Int64 $a
	 * @param int $b
	 * 
	 * @return ___Int64
	 */
	static public function ushr ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:433: characters 3-10
		$b = $b & 63;
		#/usr/local/lib/haxe/std/haxe/Int64.hx:434: lines 434-436
		if ($b === 0) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:434: characters 23-31
			$this1 = new ___Int64($a->high, $a->low);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:434: characters 23-31
			return $this1;
		} else if ($b < 32) {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:435: characters 22-78
			$this2 = new ___Int64(Boot::shiftRightUnsigned($a->high, $b), (((($a->high << (32 - $b) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits) | Boot::shiftRightUnsigned($a->low, $b)) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
			#/usr/local/lib/haxe/std/haxe/Int64.hx:435: characters 22-78
			return $this2;
		} else {
			#/usr/local/lib/haxe/std/haxe/Int64.hx:436: characters 9-39
			$this3 = new ___Int64(0, Boot::shiftRightUnsigned($a->high, ($b - 32)));
			#/usr/local/lib/haxe/std/haxe/Int64.hx:436: characters 9-39
			return $this3;
		}
	}


	/**
	 * Returns the bitwise XOR of `a` and `b`.
	 * 
	 * @param ___Int64 $a
	 * @param ___Int64 $b
	 * 
	 * @return ___Int64
	 */
	static public function xor ($a, $b) {
		#/usr/local/lib/haxe/std/haxe/Int64.hx:405: characters 10-48
		$this1 = new ___Int64((($a->high ^ $b->high) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits, (($a->low ^ $b->low) << Int32_Impl_::$extraBits) >> Int32_Impl_::$extraBits);
		#/usr/local/lib/haxe/std/haxe/Int64.hx:405: characters 10-48
		return $this1;
	}
}


Boot::registerClass(Int64_Impl_::class, 'haxe._Int64.Int64_Impl_');
Boot::registerGetters('haxe\\_Int64\\Int64_Impl_', [
	'low' => true,
	'high' => true
]);
