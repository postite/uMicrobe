<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ da28365)
 * Haxe source file: /usr/local/lib/haxe/std/DateTools.hx
 */

use \php\Boot;
use \php\_Boot\HxAnon;

/**
 * The DateTools class contains some extra functionalities for handling `Date`
 * instances and timestamps.
 * In the context of Haxe dates, a timestamp is defined as the number of
 * milliseconds elapsed since 1st January 1970.
 */
class DateTools {
	/**
	 * @var \Array_hx
	 */
	static public $DAYS_OF_MONTH;


	/**
	 * Converts a number of days to a timestamp.
	 * 
	 * @param float $n
	 * 
	 * @return float
	 */
	static public function days ($n) {
		#/usr/local/lib/haxe/std/DateTools.hx:206: characters 3-41
		return $n * 24.0 * 60.0 * 60.0 * 1000.0;
	}


	/**
	 * Returns the result of adding timestamp `t` to Date `d`.
	 * This is a convenience function for calling
	 * `Date.fromTime(d.getTime() + t)`.
	 * 
	 * @param \Date $d
	 * @param float $t
	 * 
	 * @return \Date
	 */
	static public function delta ($d, $t) {
		#/usr/local/lib/haxe/std/DateTools.hx:160: characters 3-42
		return \Date::fromTime($d->getTime() + $t);
	}


	/**
	 * Format the date `d` according to the format `f`. The format is
	 * compatible with the `strftime` standard format, except that there is no
	 * support in Flash and JS for day and months names (due to lack of proper
	 * internationalization API). On Haxe/Neko/Windows, some formats are not
	 * supported.
	 * ```haxe
	 * var t = DateTools.format(Date.now(), "%Y-%m-%d_%H:%M:%S");
	 * // 2016-07-08_14:44:05
	 * var t = DateTools.format(Date.now(), "%r");
	 * // 02:44:05 PM
	 * var t = DateTools.format(Date.now(), "%T");
	 * // 14:44:05
	 * var t = DateTools.format(Date.now(), "%F");
	 * // 2016-07-08
	 * ```
	 * 
	 * @param \Date $d
	 * @param string $f
	 * 
	 * @return string
	 */
	static public function format ($d, $f) {
		#/usr/local/lib/haxe/std/DateTools.hx:147: characters 4-72
		return strftime($f, (int)($d->__t));
	}


	/**
	 * Returns the number of days in the month of Date `d`.
	 * This method handles leap years.
	 * 
	 * @param \Date $d
	 * 
	 * @return int
	 */
	static public function getMonthDays ($d) {
		#/usr/local/lib/haxe/std/DateTools.hx:171: characters 3-28
		$month = $d->getMonth();
		#/usr/local/lib/haxe/std/DateTools.hx:172: characters 3-30
		$year = $d->getFullYear();
		#/usr/local/lib/haxe/std/DateTools.hx:174: lines 174-175
		if ($month !== 1) {
			#/usr/local/lib/haxe/std/DateTools.hx:175: characters 4-31
			return (DateTools::$DAYS_OF_MONTH->arr[$month] ?? null);
		}
		#/usr/local/lib/haxe/std/DateTools.hx:177: characters 3-73
		$isB = ((($year % 4) === 0) && (($year % 100) !== 0)) || (($year % 400) === 0);
		#/usr/local/lib/haxe/std/DateTools.hx:178: characters 10-29
		if ($isB) {
			#/usr/local/lib/haxe/std/DateTools.hx:178: characters 19-21
			return 29;
		} else {
			#/usr/local/lib/haxe/std/DateTools.hx:178: characters 27-29
			return 28;
		}
	}


	/**
	 * Converts a number of hours to a timestamp.
	 * 
	 * @param float $n
	 * 
	 * @return float
	 */
	static public function hours ($n) {
		#/usr/local/lib/haxe/std/DateTools.hx:199: characters 3-34
		return $n * 60.0 * 60.0 * 1000.0;
	}


	/**
	 * Build a date-time from several components
	 * 
	 * @param object $o
	 * 
	 * @return float
	 */
	static public function make ($o) {
		#/usr/local/lib/haxe/std/DateTools.hx:229: characters 3-93
		return $o->ms + 1000.0 * ($o->seconds + 60.0 * ($o->minutes + 60.0 * ($o->hours + 24.0 * $o->days)));
	}


	/**
	 * Retrieve Unix timestamp value from Date components. Takes same argument sequence as the Date constructor.
	 * 
	 * @param int $year
	 * @param int $month
	 * @param int $day
	 * @param int $hour
	 * @param int $min
	 * @param int $sec
	 * 
	 * @return float
	 */
	static public function makeUtc ($year, $month, $day, $hour, $min, $sec) {
		#/usr/local/lib/haxe/std/DateTools.hx:240: characters 6-77
		return gmmktime($hour, $min, $sec, $month + 1, $day, $year) * 1000;
	}


	/**
	 * Converts a number of minutes to a timestamp.
	 * 
	 * @param float $n
	 * 
	 * @return float
	 */
	static public function minutes ($n) {
		#/usr/local/lib/haxe/std/DateTools.hx:192: characters 3-27
		return $n * 60.0 * 1000.0;
	}


	/**
	 * Separate a date-time into several components
	 * 
	 * @param float $t
	 * 
	 * @return object
	 */
	static public function parse ($t) {
		#/usr/local/lib/haxe/std/DateTools.hx:213: characters 3-20
		$s = $t / 1000;
		#/usr/local/lib/haxe/std/DateTools.hx:214: characters 3-18
		$m = $s / 60;
		#/usr/local/lib/haxe/std/DateTools.hx:215: characters 3-18
		$h = $m / 60;
		#/usr/local/lib/haxe/std/DateTools.hx:218: characters 14-29
		$tmp = (int)(fmod($s, 60));
		#/usr/local/lib/haxe/std/DateTools.hx:219: characters 14-29
		$tmp1 = (int)(fmod($m, 60));
		#/usr/local/lib/haxe/std/DateTools.hx:220: characters 12-27
		$tmp2 = (int)(fmod($h, 24));
		#/usr/local/lib/haxe/std/DateTools.hx:216: lines 216-222
		return new HxAnon([
			"ms" => fmod($t, 1000),
			"seconds" => $tmp,
			"minutes" => $tmp1,
			"hours" => $tmp2,
			"days" => (int)($h / 24),
		]);
	}


	/**
	 * Converts a number of seconds to a timestamp.
	 * 
	 * @param float $n
	 * 
	 * @return float
	 */
	static public function seconds ($n) {
		#/usr/local/lib/haxe/std/DateTools.hx:185: characters 3-20
		return $n * 1000.0;
	}


	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


self::$DAYS_OF_MONTH = \Array_hx::wrap([
	31,
	28,
	31,
	30,
	31,
	30,
	31,
	31,
	30,
	31,
	30,
	31,
]);
	}
}


Boot::registerClass(DateTools::class, 'DateTools');
DateTools::__hx__init();
