<?php

// Generated by Haxe 3.4.7
class image_Image {
	public function __construct(){}
	static function resize($input, $output, $options) {
		$GLOBALS['%s']->push("image.Image::resize");
		$__hx__spos = $GLOBALS['%s']->length;
		$tmp = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
		$tmp1 = "1" . Std::string($options);
		call_user_func_array($tmp, array($tmp1, _hx_anonymous(array("fileName" => "Image.hx", "lineNumber" => 48, "className" => "image.Image", "methodName" => "resize"))));
		if($options->crop === null) {
			$options->crop = true;
		}
		if(_hx_field($options, "focus") === null) {
			$options->focus = _hx_anonymous(array("x" => .5, "y" => .5));
		}
		$tmp2 = (property_exists("haxe_Log", "trace") ? haxe_Log::$trace: array("haxe_Log", "trace"));
		$tmp3 = "2" . Std::string($options);
		call_user_func_array($tmp2, array($tmp3, _hx_anonymous(array("fileName" => "Image.hx", "lineNumber" => 51, "className" => "image.Image", "methodName" => "resize"))));
		$info = null;
		$ratio = .0;
		$newRatio = .0;
		$cropW = 0;
		$cropH = 0;
		$width = 0;
		$height = 0;
		$sizeRatio = .0;
		$path = new haxe_io_Path($input);
		$tmp4 = "tn_" . _hx_string_or_null($path->file) . "." . _hx_string_or_null($path->ext);
		$xPos = 0;
		$yPos = 0;
		{
			$tmp5 = tink_core__Future_Future_Impl_::_flatMap(tink_core__Future_Future_Impl_::_flatMap(tink_core__Future_Future_Impl_::_flatMap(image_Image::getInfo($input), array(new _hx_lambda(array(&$cropH, &$cropW, &$height, &$info, &$input, &$newRatio, &$options, &$output, &$ratio, &$sizeRatio, &$tmp4, &$width, &$xPos, &$yPos), "image_Image_0"), 'execute')), array(new _hx_lambda(array(&$options, &$output, &$path, &$tmp4, &$xPos, &$yPos), "image_Image_1"), 'execute')), array(new _hx_lambda(array(&$options, &$path, &$tmp4), "image_Image_2"), 'execute'));
			$GLOBALS['%s']->pop();
			return $tmp5;
		}
		$GLOBALS['%s']->pop();
	}
	static function getInfo($path) {
		$GLOBALS['%s']->push("image.Image::getInfo");
		$__hx__spos = $GLOBALS['%s']->length;
		$trigger = new tink_core_FutureTrigger();
		$width = 0;
		$height = 0;
		$format = null;
		$unsupported = "Unsupported image format";
		{
			$tmp = tink_core__Future_Future_Impl_::_map(asys_io_File::read($path, null), array(new _hx_lambda(array(&$format, &$height, &$unsupported, &$width), "image_Image_3"), 'execute'));
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	function __toString() { return 'image.Image'; }
}
function image_Image_0(&$cropH, &$cropW, &$height, &$info, &$input, &$newRatio, &$options, &$output, &$ratio, &$sizeRatio, &$tmp4, &$width, &$xPos, &$yPos, $res) {
	{
		$GLOBALS['%s']->push("image.Image::resize@65");
		$__hx__spos = $GLOBALS['%s']->length;
		switch($res->index) {
		case 0:{
			$i = _hx_deref($res)->params[0];
			$info = $i;
			$ratio = $info->width / $info->height;
			$newRatio = $options->width / $options->height;
			if($ratio > $newRatio) {
				$height = $options->height;
				$width = Math::round($options->height * $ratio);
				$cropH = $info->height;
				$cropW = Math::round($info->width / $width * $options->width);
				$sizeRatio = $options->height / $info->height;
			} else {
				$height = Math::round($options->width / $ratio);
				$width = $options->width;
				$cropW = $info->width;
				$cropH = Math::round($info->height / $height * $options->height);
				$sizeRatio = $options->width / $info->width;
			}
			$xPos = Math::round($options->focus->x * $info->width - $cropW / 2);
			$yPos = Math::round($options->focus->y * $info->height - $cropH / 2);
			if($xPos + $cropW > $info->width) {
				$xPos = $info->width - $cropW;
			}
			if($yPos + $cropH > $info->height) {
				$yPos = $info->height - $cropH;
			}
			if($xPos < 0) {
				$xPos = 0;
			}
			if($yPos < 0) {
				$yPos = 0;
			}
			$_g = $options->engine;
			$tmp5 = null;
			if($_g->index === 3) {
				$tmp5 = true;
			} else {
				$tmp5 = false;
			}
			if($tmp5) {
				try {
					$createFrom = "imagecreatefrom" . _hx_string_or_null($info->format);
					$src = $createFrom($input);
					$dst = imagecreatetruecolor($options->width, $options->height);
					$outputPath = new haxe_io_Path($output);
					if($outputPath->ext === "png") {
						if (function_exists('imagecolorallocatealpha')) {
								imagealphablending($dst, false);
								imagesavealpha($dst, true);
								$transparent = imagecolorallocatealpha($dst, 255, 255, 255, 127);
								imagefilledrectangle($dst, 0, 0, $options->width, $options->height, $transparent);
							}
					}
					imagecopyresampled($dst, $src, 0, 0, $xPos, $yPos, $options->width, $options->height, $cropW, $cropH);
					imagedestroy($src);
					{
						$_g1 = strtolower($outputPath->ext);
						switch($_g1) {
						case "bmp":{
							imagewbmp($dst, $output);
						}break;
						case "gif":{
							imagegif($dst, $output);
						}break;
						case "jpeg":case "jpg":{
							imagejpeg($dst, $output, 96);
						}break;
						case "png":{
							imagepng($dst, $output, 9);
						}break;
						default:{
							$outFunc = "image" . _hx_string_or_null($outputPath->ext);
							$outFunc($dst, $output);
						}break;
						}
					}
					imagedestroy($dst);
					{
						$tmp = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(tink_core_Outcome::Success(tink_core_Noise::$Noise)));
						$GLOBALS['%s']->pop();
						return $tmp;
					}
				}catch(Exception $__hx__e) {
					$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
					$e = $_ex_;
					{
						$GLOBALS['%e'] = (new _hx_array(array()));
						while($GLOBALS['%s']->length >= $__hx__spos) {
							$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
						}
						$GLOBALS['%s']->push($GLOBALS['%e'][0]);
						{
							$tmp = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(tink_core_Outcome::Failure($e)));
							$GLOBALS['%s']->pop();
							return $tmp;
						}
					}
				}
			}
			$xPos = Math::round($xPos * $sizeRatio);
			$yPos = Math::round($yPos * $sizeRatio);
			$cmd = null;
			$_g11 = $options->engine;
			switch($_g11->index) {
			case 0:{
				$cmd = "vipsthumbnail";
			}break;
			case 1:{
				$cmd = "convert";
			}break;
			case 2:{
				$cmd = "gm";
			}break;
			default:{
				$cmd = null;
			}break;
			}
			$args = null;
			$_g2 = $options->engine;
			switch($_g2->index) {
			case 0:{
				$args = (new _hx_array(array($input, "-s", "" . _hx_string_rec($width, "") . "x" . _hx_string_rec($height, ""), "-c", "-o", $tmp4)));
			}break;
			case 1:{
				$args = (new _hx_array(array($input, "-resize", "" . _hx_string_rec($width, "") . "x" . _hx_string_rec($height, ""), "-crop", "" . _hx_string_rec($options->width, "") . "x" . _hx_string_rec($options->height, "") . "+" . _hx_string_rec($xPos, "") . "+" . _hx_string_rec($yPos, ""), "-strip", "+repage", $output)));
			}break;
			case 2:{
				$args = (new _hx_array(array("convert", $input, "-resize", "" . _hx_string_rec($width, "") . "x" . _hx_string_rec($height, ""), "-crop", "" . _hx_string_rec($options->width, "") . "x" . _hx_string_rec($options->height, "") . "+" . _hx_string_rec($xPos, "") . "+" . _hx_string_rec($yPos, ""), "-strip", "+repage", $output)));
			}break;
			default:{
				$args = null;
			}break;
			}
			$process = new asys_io_Process($cmd, $args);
			{
				$tmp = tink_core__Future_Future_Impl_::_map($process->exitCode(), array(new _hx_lambda(array(), "image_Image_4"), 'execute'));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 1:{
			$e1 = _hx_deref($res)->params[0];
			{
				$tmp = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(tink_core_Outcome::Failure($e1)));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		}
		$GLOBALS['%s']->pop();
	}
}
function image_Image_1(&$options, &$output, &$path, &$tmp4, &$xPos, &$yPos, $res1) {
	{
		$GLOBALS['%s']->push("image.Image::resize@171");
		$__hx__spos = $GLOBALS['%s']->length;
		switch($res1->index) {
		case 0:{
			{
				$_g3 = $options->engine;
				if($_g3->index !== 0) {
					$tmp = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(tink_core_Outcome::Success(tink_core_Noise::$Noise)));
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			}
			$process1 = haxe_io_Path::join((new _hx_array(array($path->dir, $tmp4))));
			$process2 = new asys_io_Process("vips", (new _hx_array(array("crop", $process1, $output, "" . _hx_string_rec($xPos, ""), "" . _hx_string_rec($yPos, ""), "" . _hx_string_rec($options->width, ""), "" . _hx_string_rec($options->height, "")))));
			{
				$tmp = tink_core__Future_Future_Impl_::_map($process2->exitCode(), array(new _hx_lambda(array(), "image_Image_5"), 'execute'));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 1:{
			$e2 = _hx_deref($res1)->params[0];
			{
				$tmp = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(tink_core_Outcome::Failure($e2)));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		}
		$GLOBALS['%s']->pop();
	}
}
function image_Image_2(&$options, &$path, &$tmp4, $res2) {
	{
		$GLOBALS['%s']->push("image.Image::resize@196");
		$__hx__spos = $GLOBALS['%s']->length;
		switch($res2->index) {
		case 0:{
			{
				$_g4 = $options->engine;
				if($_g4->index !== 0) {
					$tmp = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(tink_core_Outcome::Success(tink_core_Noise::$Noise)));
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			}
			{
				$tmp = asys_FileSystem::deleteFile(haxe_io_Path::join((new _hx_array(array($path->dir, $tmp4)))));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 1:{
			$e3 = _hx_deref($res2)->params[0];
			{
				$tmp = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(tink_core_Outcome::Failure($e3)));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		}
		$GLOBALS['%s']->pop();
	}
}
function image_Image_3(&$format, &$height, &$unsupported, &$width, $res) {
	{
		$GLOBALS['%s']->push("image.Image::getInfo@218");
		$__hx__spos = $GLOBALS['%s']->length;
		switch($res->index) {
		case 0:{
			$input = _hx_deref($res)->params[0];
			{
				$_g = $input->readUInt16();
				switch($_g) {
				case 18759:{
					$endian = $_g;
					$tmp = null;
					if($endian !== 18761) {
						$tmp = $endian === 19789;
					} else {
						$tmp = true;
					}
					if($tmp) {
						$input->set_bigEndian($endian === 19789);
						if($input->readUInt16() !== 42) {
							$tmp2 = tink_core_Outcome::Failure(new tink_core_TypedError(null, $unsupported, _hx_anonymous(array("fileName" => "Image.hx", "lineNumber" => 242, "className" => "image.Image", "methodName" => "getInfo"))));
							$GLOBALS['%s']->pop();
							return $tmp2;
						}
						$format = "tiff";
						$offset = $input->readInt32();
						$input->seek($offset, sys_io_FileSeek::$SeekBegin);
						$count = $input->readUInt16();
						while(true) {
							$tmp1 = null;
							$count = $count - 1;
							if($count + 1 > 0) {
								if($width !== 0) {
									$tmp1 = $height === 0;
								} else {
									$tmp1 = true;
								}
							} else {
								$tmp1 = false;
							}
							if(!$tmp1) {
								break;
							}
							$tag = $input->readUInt16();
							$type = $input->readUInt16();
							$values = $input->readInt32();
							$value = null;
							if($type === 3) {
								$t = $input->readUInt16();
								$input->readUInt16();
								$value = $t;
								unset($t);
							} else {
								$value = $input->readInt32();
							}
							switch($tag) {
							case 256:{
								$width = $value;
							}break;
							case 257:{
								$height = $value;
							}break;
							default:{}break;
							}
							unset($values,$value,$type,$tmp1,$tag);
						}
					} else {
						$format = "gif";
						$input->readInt32();
						$width = $input->readUInt16();
						$height = $input->readUInt16();
					}
				}break;
				case 18770:{
					$input->seek(6, sys_io_FileSeek::$SeekCur);
					if($input->readString(4) !== "WEBP") {
						$tmp = tink_core_Outcome::Failure(new tink_core_TypedError(null, $unsupported, _hx_anonymous(array("fileName" => "Image.hx", "lineNumber" => 224, "className" => "image.Image", "methodName" => "getInfo"))));
						$GLOBALS['%s']->pop();
						return $tmp;
					}
					$format = "webp";
					{
						$_g1 = $input->readString(4);
						switch($_g1) {
						case "VP8 ":{
							$input->seek(10, sys_io_FileSeek::$SeekCur);
							$width = $input->readUInt16();
							$height = $input->readUInt16();
						}break;
						case "VP8L":{
							$input->seek(5, sys_io_FileSeek::$SeekCur);
							$b0 = $input->readByte();
							$b1 = $input->readByte();
							$b2 = $input->readByte();
							$b3 = $input->readByte();
							$width = 1 + (($b1 & 63) << 8 | $b0);
							$height = 1 + (($b3 & 15) << 10 | $b2 << 2 | ($b1 & 192) >> 6);
						}break;
						default:{
							$tmp = tink_core_Outcome::Failure(new tink_core_TypedError(null, $unsupported, _hx_anonymous(array("fileName" => "Image.hx", "lineNumber" => 237, "className" => "image.Image", "methodName" => "getInfo"))));
							$GLOBALS['%s']->pop();
							return $tmp;
						}break;
						}
					}
				}break;
				case 19778:{
					$endian1 = $_g;
					$tmp2 = null;
					if($endian1 !== 18761) {
						$tmp2 = $endian1 === 19789;
					} else {
						$tmp2 = true;
					}
					if($tmp2) {
						$input->set_bigEndian($endian1 === 19789);
						if($input->readUInt16() !== 42) {
							$tmp = tink_core_Outcome::Failure(new tink_core_TypedError(null, $unsupported, _hx_anonymous(array("fileName" => "Image.hx", "lineNumber" => 242, "className" => "image.Image", "methodName" => "getInfo"))));
							$GLOBALS['%s']->pop();
							return $tmp;
						}
						$format = "tiff";
						$offset1 = $input->readInt32();
						$input->seek($offset1, sys_io_FileSeek::$SeekBegin);
						$count1 = $input->readUInt16();
						while(true) {
							$tmp3 = null;
							$count1 = $count1 - 1;
							if($count1 + 1 > 0) {
								if($width !== 0) {
									$tmp3 = $height === 0;
								} else {
									$tmp3 = true;
								}
							} else {
								$tmp3 = false;
							}
							if(!$tmp3) {
								break;
							}
							$tag1 = $input->readUInt16();
							$type1 = $input->readUInt16();
							$values1 = $input->readInt32();
							$value1 = null;
							if($type1 === 3) {
								$t1 = $input->readUInt16();
								$input->readUInt16();
								$value1 = $t1;
								unset($t1);
							} else {
								$value1 = $input->readInt32();
							}
							switch($tag1) {
							case 256:{
								$width = $value1;
							}break;
							case 257:{
								$height = $value1;
							}break;
							default:{}break;
							}
							unset($values1,$value1,$type1,$tmp3,$tag1);
						}
					} else {
						$format = "wbmp";
						$input->seek(16, sys_io_FileSeek::$SeekCur);
						$width = $input->readInt32();
						$height = $input->readInt32();
					}
				}break;
				case 20617:{
					$endian2 = $_g;
					$tmp4 = null;
					if($endian2 !== 18761) {
						$tmp4 = $endian2 === 19789;
					} else {
						$tmp4 = true;
					}
					if($tmp4) {
						$input->set_bigEndian($endian2 === 19789);
						if($input->readUInt16() !== 42) {
							$tmp = tink_core_Outcome::Failure(new tink_core_TypedError(null, $unsupported, _hx_anonymous(array("fileName" => "Image.hx", "lineNumber" => 242, "className" => "image.Image", "methodName" => "getInfo"))));
							$GLOBALS['%s']->pop();
							return $tmp;
						}
						$format = "tiff";
						$offset2 = $input->readInt32();
						$input->seek($offset2, sys_io_FileSeek::$SeekBegin);
						$count2 = $input->readUInt16();
						while(true) {
							$tmp5 = null;
							$count2 = $count2 - 1;
							if($count2 + 1 > 0) {
								if($width !== 0) {
									$tmp5 = $height === 0;
								} else {
									$tmp5 = true;
								}
							} else {
								$tmp5 = false;
							}
							if(!$tmp5) {
								break;
							}
							$tag2 = $input->readUInt16();
							$type2 = $input->readUInt16();
							$values2 = $input->readInt32();
							$value2 = null;
							if($type2 === 3) {
								$t2 = $input->readUInt16();
								$input->readUInt16();
								$value2 = $t2;
								unset($t2);
							} else {
								$value2 = $input->readInt32();
							}
							switch($tag2) {
							case 256:{
								$width = $value2;
							}break;
							case 257:{
								$height = $value2;
							}break;
							default:{}break;
							}
							unset($values2,$value2,$type2,$tmp5,$tag2);
						}
					} else {
						$format = "png";
						$tmp6 = haxe_io_Bytes::alloc(256);
						$input->set_bigEndian(true);
						$input->readBytes($tmp6, 0, 6);
						$i = 200;
						while(true) {
							$i = $i - 1;
							if(!($i + 1 > 0)) {
								break;
							}
							$dataLen = $input->readInt32();
							if($input->readInt32() === 1229472850) {
								$width = $input->readInt32();
								$height = $input->readInt32();
								break;
							}
							while($dataLen > 0) {
								$k = null;
								if($dataLen > $tmp6->length) {
									$k = $tmp6->length;
								} else {
									$k = $dataLen;
								}
								$input->readBytes($tmp6, 0, $k);
								$dataLen = $dataLen - $k;
								unset($k);
							}
							$crc = $input->readInt32();
							unset($dataLen,$crc);
						}
					}
				}break;
				case 55551:{
					$endian3 = $_g;
					$tmp7 = null;
					if($endian3 !== 18761) {
						$tmp7 = $endian3 === 19789;
					} else {
						$tmp7 = true;
					}
					if($tmp7) {
						$input->set_bigEndian($endian3 === 19789);
						if($input->readUInt16() !== 42) {
							$tmp = tink_core_Outcome::Failure(new tink_core_TypedError(null, $unsupported, _hx_anonymous(array("fileName" => "Image.hx", "lineNumber" => 242, "className" => "image.Image", "methodName" => "getInfo"))));
							$GLOBALS['%s']->pop();
							return $tmp;
						}
						$format = "tiff";
						$offset3 = $input->readInt32();
						$input->seek($offset3, sys_io_FileSeek::$SeekBegin);
						$count3 = $input->readUInt16();
						while(true) {
							$tmp8 = null;
							$count3 = $count3 - 1;
							if($count3 + 1 > 0) {
								if($width !== 0) {
									$tmp8 = $height === 0;
								} else {
									$tmp8 = true;
								}
							} else {
								$tmp8 = false;
							}
							if(!$tmp8) {
								break;
							}
							$tag3 = $input->readUInt16();
							$type3 = $input->readUInt16();
							$values3 = $input->readInt32();
							$value3 = null;
							if($type3 === 3) {
								$t3 = $input->readUInt16();
								$input->readUInt16();
								$value3 = $t3;
								unset($t3);
							} else {
								$value3 = $input->readInt32();
							}
							switch($tag3) {
							case 256:{
								$width = $value3;
							}break;
							case 257:{
								$height = $value3;
							}break;
							default:{}break;
							}
							unset($values3,$value3,$type3,$tmp8,$tag3);
						}
					} else {
						$format = "jpeg";
						$input->set_bigEndian(true);
						$i1 = 200;
						while(true) {
							$i1 = $i1 - 1;
							if(!($i1 + 1 > 0)) {
								break;
							}
							{
								$_g2 = $input->readUInt16();
								switch($_g2) {
								case 65472:case 65474:{
									$len = $input->readUInt16();
									$prec = $input->readByte();
									$height = $input->readUInt16();
									$width = $input->readUInt16();
									break 2;
								}break;
								default:{
									$input->seek($input->readUInt16() - 2, sys_io_FileSeek::$SeekCur);
								}break;
								}
								unset($_g2);
							}
						}
					}
				}break;
				default:{
					$endian4 = $_g;
					$tmp9 = null;
					if($endian4 !== 18761) {
						$tmp9 = $endian4 === 19789;
					} else {
						$tmp9 = true;
					}
					if($tmp9) {
						$input->set_bigEndian($endian4 === 19789);
						if($input->readUInt16() !== 42) {
							$tmp = tink_core_Outcome::Failure(new tink_core_TypedError(null, $unsupported, _hx_anonymous(array("fileName" => "Image.hx", "lineNumber" => 242, "className" => "image.Image", "methodName" => "getInfo"))));
							$GLOBALS['%s']->pop();
							return $tmp;
						}
						$format = "tiff";
						$offset4 = $input->readInt32();
						$input->seek($offset4, sys_io_FileSeek::$SeekBegin);
						$count4 = $input->readUInt16();
						while(true) {
							$tmp10 = null;
							$count4 = $count4 - 1;
							if($count4 + 1 > 0) {
								if($width !== 0) {
									$tmp10 = $height === 0;
								} else {
									$tmp10 = true;
								}
							} else {
								$tmp10 = false;
							}
							if(!$tmp10) {
								break;
							}
							$tag4 = $input->readUInt16();
							$type4 = $input->readUInt16();
							$values4 = $input->readInt32();
							$value4 = null;
							if($type4 === 3) {
								$t4 = $input->readUInt16();
								$input->readUInt16();
								$value4 = $t4;
								unset($t4);
							} else {
								$value4 = $input->readInt32();
							}
							switch($tag4) {
							case 256:{
								$width = $value4;
							}break;
							case 257:{
								$height = $value4;
							}break;
							default:{}break;
							}
							unset($values4,$value4,$type4,$tmp10,$tag4);
						}
					} else {
						$tmp = tink_core_Outcome::Failure(new tink_core_TypedError(null, $unsupported, _hx_anonymous(array("fileName" => "Image.hx", "lineNumber" => 308, "className" => "image.Image", "methodName" => "getInfo"))));
						$GLOBALS['%s']->pop();
						return $tmp;
					}
				}break;
				}
			}
			$input->close();
			{
				$tmp = tink_core_Outcome::Success(_hx_anonymous(array("width" => $width, "height" => $height, "format" => $format)));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 1:{
			$e = _hx_deref($res)->params[0];
			{
				$tmp = tink_core_Outcome::Failure($e);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		}
		$GLOBALS['%s']->pop();
	}
}
function image_Image_4($code) {
	{
		$GLOBALS['%s']->push("image.Image::getInfo@162");
		$__hx__spos = $GLOBALS['%s']->length;
		if($code === 0) {
			$tmp = tink_core_Outcome::Success(tink_core_Noise::$Noise);
			$GLOBALS['%s']->pop();
			return $tmp;
		} else {
			$tmp = tink_core_Outcome::Failure(new tink_core_TypedError(null, "Resize process exited with: " . _hx_string_rec($code, ""), _hx_anonymous(array("fileName" => "Image.hx", "lineNumber" => 166, "className" => "image.Image", "methodName" => "resize"))));
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
}
function image_Image_5($code1) {
	{
		$GLOBALS['%s']->push("image.Image::getInfo@187");
		$__hx__spos = $GLOBALS['%s']->length;
		if($code1 === 0) {
			$tmp = tink_core_Outcome::Success(tink_core_Noise::$Noise);
			$GLOBALS['%s']->pop();
			return $tmp;
		} else {
			$tmp = tink_core_Outcome::Failure(new tink_core_TypedError(null, "Crop process exited with: " . _hx_string_rec($code1, ""), _hx_anonymous(array("fileName" => "Image.hx", "lineNumber" => 191, "className" => "image.Image", "methodName" => "resize"))));
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
}
