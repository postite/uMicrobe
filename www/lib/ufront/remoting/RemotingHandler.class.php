<?php

// Generated by Haxe 3.4.7
class ufront_remoting_RemotingHandler implements ufront_app_UFRequestHandler{
	public function __construct() {
		if(!php_Boot::$skip_constructor) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::new");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->apiContexts = new HList();
		$this->apis = new HList();
		$GLOBALS['%s']->pop();
	}}
	public $apiContexts;
	public $apis;
	public $context;
	public function loadApi($api) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::loadApi");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->apis->push($api);
		$GLOBALS['%s']->pop();
	}
	public function loadApis($newAPIs) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::loadApis");
		$__hx__spos = $GLOBALS['%s']->length;
		$api = $newAPIs->iterator();
		while($api->hasNext()) {
			$api1 = $api->next();
			$this->apis->push($api1);
			unset($api1);
		}
		$GLOBALS['%s']->pop();
	}
	public function loadApiContext($apiContext) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::loadApiContext");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->apiContexts->push($apiContext);
		{
			$newAPIs = ufront_api_UFApiContext::getApisInContext($apiContext);
			{
				$api = $newAPIs->iterator();
				while($api->hasNext()) {
					$api1 = $api->next();
					$this->apis->push($api1);
					unset($api1);
				}
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function handleRequest($httpContext) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::handleRequest");
		$__hx__spos = $GLOBALS['%s']->length;
		$doneTrigger = new tink_core_FutureTrigger();
		$this1 = $httpContext->request->get_clientHeaders();
		if($this1->exists(strtolower("X-Haxe-Remoting"))) {
			$r = $httpContext->response;
			$remotingResponse = null;
			$r->setOk();
			$path = null;
			$args = null;
			try {
				$this->initializeContext($httpContext->injector);
				$params = $httpContext->request->get_params();
				if(!$params->exists("__x")) {
					throw new HException("Remoting call did not have parameter `__x` which describes which API call to make.  Aborting");
				}
				$remotingCall = ufront_core__MultiValueMap_MultiValueMap_Impl_::get($params, "__x");
				$u = new ufront_remoting_RemotingUnserializer($remotingCall, $httpContext->request->get_files());
				try {
					$path = $u->unserialize();
					$args = $u->unserialize();
					{
						$_g1 = 0;
						$_g = $args->length;
						while($_g1 < $_g) {
							$_g1 = $_g1 + 1;
							$i = $_g1 - 1;
							$baseUpload = Std::instance($args[$i], _hx_qtype("ufront.web.upload.BaseUpload"));
							$tmp = null;
							if($baseUpload !== null) {
								$tmp = $baseUpload->attachedUpload !== null;
							} else {
								$tmp = false;
							}
							if($tmp) {
								$args[$i] = $baseUpload->attachedUpload;
							}
							unset($tmp,$i,$baseUpload);
						}
					}
				}catch(Exception $__hx__e) {
					$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
					$e = $_ex_;
					{
						$GLOBALS['%e'] = (new _hx_array(array()));
						while($GLOBALS['%s']->length >= $__hx__spos) {
							$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
						}
						$GLOBALS['%s']->push($GLOBALS['%e'][0]);
						throw new HException("Unable to deserialize remoting call: " . Std::string($e) . ". Remoting call string: " . _hx_string_or_null($remotingCall));
					}
				}
				$apiCallFinished = $this->executeApiCall($path, $args, $this->context, $httpContext->actionContext);
				$ret = $apiCallFinished->map(array(new _hx_lambda(array(), "ufront_remoting_RemotingHandler_0"), 'execute'));
				$remotingResponse = $ret->gather();
			}catch(Exception $__hx__e) {
				$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
				$e1 = $_ex_;
				{
					$GLOBALS['%e'] = (new _hx_array(array()));
					while($GLOBALS['%s']->length >= $__hx__spos) {
						$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
					}
					$GLOBALS['%s']->push($GLOBALS['%e'][0]);
					$error = $e1;
					$apiNotFoundMessages = (new _hx_array(array("Invalid path", "No such object", "Can't access", "No such method")));
					$tmp1 = null;
					$tmp2 = null;
					$tmp3 = null;
					if($path !== null) {
						$tmp3 = $args !== null;
					} else {
						$tmp3 = false;
					}
					if($tmp3) {
						$tmp2 = Std::is($e1, _hx_qtype("String"));
					} else {
						$tmp2 = false;
					}
					if($tmp2) {
						$tmp1 = Lambda::exists($apiNotFoundMessages, array(new _hx_lambda(array(&$error), "ufront_remoting_RemotingHandler_1"), 'execute'));
					} else {
						$tmp1 = false;
					}
					if($tmp1) {
						$v = "Unable to access " . _hx_string_or_null($path->join(".")) . " - API Not Found (";
						$v1 = _hx_string_or_null($v) . _hx_string_or_null($error) . "). See ";
						$remotingResponse = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(_hx_string_or_null($v1) . Std::string($this->context->objects)));
						$r->setNotFound();
					} else {
						$r->setInternalError();
						$remotingResponse = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst($this->remotingError($e1, $httpContext)));
					}
				}
			}
			$remotingResponse->handle(array(new _hx_lambda(array(&$doneTrigger, &$httpContext, &$r), "ufront_remoting_RemotingHandler_2"), 'execute'));
		} else {
			$doneTrigger->trigger(tink_core_Outcome::Success(tink_core_Noise::$Noise));
		}
		{
			$tmp = $doneTrigger;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function initializeContext($injector) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::initializeContext");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->context = new haxe_remoting_Context();
		{
			$apiContextClass = $this->apiContexts->iterator();
			while($apiContextClass->hasNext()) {
				$apiContextClass1 = $apiContextClass->next();
				$apiContext = $injector->_instantiate($apiContextClass1);
				{
					$_g = 0;
					$_g1 = Reflect::fields($apiContext);
					while($_g < $_g1->length) {
						$fieldName = $_g1[$_g];
						$_g = $_g + 1;
						$api = Reflect::field($apiContext, $fieldName);
						if(Reflect::isObject($api)) {
							$this->context->addObject($fieldName, $api, false);
						}
						unset($fieldName,$api);
					}
					unset($_g1,$_g);
				}
				unset($apiContextClass1,$apiContext);
			}
		}
		{
			$apiClass = $this->apis->iterator();
			while($apiClass->hasNext()) {
				$apiClass1 = $apiClass->next();
				$className = Type::getClassName($apiClass1);
				$api1 = $injector->_instantiate($apiClass1);
				$this->context->addObject($className, $api1, false);
				unset($className,$apiClass1,$api1);
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function executeApiCall($path, $args, $remotingContext, $actionContext) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::executeApiCall");
		$__hx__spos = $GLOBALS['%s']->length;
		if($remotingContext->objects->exists($path[0]) === false) {
			throw new HException("Invalid path " . _hx_string_or_null($path->join(".")));
		}
		$actionContext->handler = $this;
		$actionContext->action = $path[$path->length - 1];
		$actionContext->controller = $remotingContext->objects->get($path[0])->obj;
		$actionContext->args = $args;
		$returnType = null;
		try {
			$fieldsMeta = haxe_rtti_Meta::getFields(Type::getClass($actionContext->controller));
			$actionMeta = Reflect::field($fieldsMeta, $actionContext->action);
			$returnType = $actionMeta->returnType[0];
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e = $_ex_;
			{
				$GLOBALS['%e'] = (new _hx_array(array()));
				while($GLOBALS['%s']->length >= $__hx__spos) {
					$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
				}
				$GLOBALS['%s']->push($GLOBALS['%e'][0]);
				{
					$_this = $actionContext->httpContext;
					$msg = "Failed to get metadata for API: " . Std::string($e);
					$_this->messages->push(_hx_anonymous(array("msg" => $msg, "pos" => _hx_anonymous(array("fileName" => "RemotingHandler.hx", "lineNumber" => 190, "className" => "ufront.remoting.RemotingHandler", "methodName" => "executeApiCall")), "type" => ufront_log_MessageType::$MError)));
				}
				$actionContext->httpContext->messages->push(_hx_anonymous(array("msg" => "Assuming API call to " . _hx_string_or_null($actionContext->action) . " returns a regular value", "pos" => _hx_anonymous(array("fileName" => "RemotingHandler.hx", "lineNumber" => 191, "className" => "ufront.remoting.RemotingHandler", "methodName" => "executeApiCall")), "type" => ufront_log_MessageType::$MError)));
				$returnType = 0;
			}
		}
		$this1 = $returnType;
		$flags = $this1;
		$result = $remotingContext->call($path, $args);
		if(($flags & 1 << ufront_api_ApiReturnType::$ARTFuture->index) !== 0) {
			$GLOBALS['%s']->pop();
			return $result;
		} else {
			if(($flags & 1 << ufront_api_ApiReturnType::$ARTVoid->index) !== 0) {
				$tmp = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst(null));
				$GLOBALS['%s']->pop();
				return $tmp;
			} else {
				$tmp = new tink_core__Future_SyncFuture(new tink_core__Lazy_LazyConst($result));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function remotingError($e, $httpContext) {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::remotingError");
		$__hx__spos = $GLOBALS['%s']->length;
		$httpContext->messages->push(_hx_anonymous(array("msg" => $e, "pos" => _hx_anonymous(array("fileName" => "RemotingHandler.hx", "lineNumber" => 209, "className" => "ufront.remoting.RemotingHandler", "methodName" => "remotingError")), "type" => ufront_log_MessageType::$MError)));
		$this1 = $httpContext->request->get_clientHeaders();
		if($this1->exists(strtolower("X-Ufront-Remoting"))) {
			$s = new ufront_remoting_RemotingSerializer(ufront_remoting_RemotingDirection::$RDServerToClient);
			$s->serializeException($e);
			$serializedException = "hxe" . _hx_string_or_null($s->toString());
			$exceptionStack = haxe_CallStack::toString(haxe_CallStack::exceptionStack());
			$serializedStack = "hxs" . _hx_string_or_null(ufront_remoting_RemotingSerializer::run($exceptionStack, ufront_remoting_RemotingDirection::$RDServerToClient));
			{
				$tmp = _hx_string_or_null($serializedStack) . "\x0A" . _hx_string_or_null($serializedException);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		} else {
			$s1 = new ufront_remoting_RemotingSerializer(ufront_remoting_RemotingDirection::$RDServerToClient);
			$s1->serializeException($e);
			{
				$tmp = "hxr" . _hx_string_or_null($s1->toString());
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function toString() {
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::toString");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$GLOBALS['%s']->pop();
			return "ufront.remoting.RemotingHandler";
		}
		$GLOBALS['%s']->pop();
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	function __toString() { return $this->toString(); }
}
function ufront_remoting_RemotingHandler_0($data) {
	{
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::handleRequest@115");
		$__hx__spos = $GLOBALS['%s']->length;
		$s = new ufront_remoting_RemotingSerializer(ufront_remoting_RemotingDirection::$RDServerToClient);
		$s->serialize($data);
		{
			$tmp = "hxr" . _hx_string_or_null($s->toString());
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
}
function ufront_remoting_RemotingHandler_1(&$error, $msg) {
	{
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::handleRequest@125");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = StringTools::startsWith($error, $msg);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
}
function ufront_remoting_RemotingHandler_2(&$doneTrigger, &$httpContext, &$r, $response) {
	{
		$GLOBALS['%s']->push("ufront.remoting.RemotingHandler::handleRequest@135");
		$__hx__spos = $GLOBALS['%s']->length;
		$r->set_contentType("application/x-haxe-remoting");
		$r->clearContent();
		$r->write($response);
		$httpContext1 = $httpContext;
		$httpContext1->completion = $httpContext1->completion | 1 << ufront_web_context_RequestCompletion::$CRequestHandlersComplete->index;
		$doneTrigger->trigger(tink_core_Outcome::Success(tink_core_Noise::$Noise));
		$GLOBALS['%s']->pop();
	}
}
