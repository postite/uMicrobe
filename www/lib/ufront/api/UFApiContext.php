<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ da28365)
 * Haxe source file: /Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx
 */

namespace ufront\api;

use \php\Boot;
use \haxe\rtti\Meta;
use \minject\Injector;

/**
 * UFApiContext is a base class for setting up your Haxe remoting API context.
 * If set in your `UfrontConfiguration.remotingApi`, your UFApiContext class will share all the APIs over both Haxe style remoting (using proxies with callbacks) and Ufront style remoting (using `UFApi` and `UFAsyncApi`).
 * An example API context might look like this:
 * ```haxe
 * class MainApi extends ufront.api.UFApiContext {
 * var userAPI:app.client.UserAPI;
 * var purchaseAPI:app.purchase.PurchasingAPI;
 * }
 * ```
 * This will make both UserAPI and PurchasingAPI available to remoting calls.
 * #### Ufront and Haxe Remoting:
 * Ufront style remoting will use `UFAsyncApi<YourApi>` classes, which return a `Surprise` (A `Future<Outcome>`) rather than a synchronous result.
 * This works well with dependency injection and ufront controllers, and is probably the best choice if you are using Ufront on your client side app.
 * See `UFAsyncApi` for more details.
 * Haxe style remoting will use `UFCallbackApi<YourApi>` classes, which use asynchronous callbacks rather than returning a result.
 * This style may feel familiar to Javascript developers, and is almost certainly the best option if your client code is not written in Ufront (or even Haxe).
 * See `UFCallbackApi` and `UFApiClientContext` for more details.
 * #### Other Notes:
 * - Every API variable will be made public and available for remoting.
 * - Functions, properties and static variables will be ignored.
 * - You don't have to worry about initialising your API variables - dependency injection will be used.
 */
class UFApiContext {
	/**
	 * @var Injector
	 */
	public $injector;


	/**
	 * Return an Array of APIs that are available in this context.
	 * 
	 * @param Class $context
	 * 
	 * @return \Array_hx
	 */
	static public function getApisInContext ($context) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:52: characters 3-17
		$apis = new \Array_hx();
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:53: characters 3-48
		$meta = Meta::getType($context);
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:54: lines 54-58
		if (Boot::dynamicField($meta, 'apiList') !== null) {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:54: lines 54-58
			$_g = 0;
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:54: lines 54-58
			$_g1 = Boot::dynamicField($meta, 'apiList');
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:54: lines 54-58
			while ($_g < $_g1->length) {
				#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:54: characters 32-39
				$apiName = ($_g1->arr[$_g] ?? null);
				#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:54: lines 54-58
				$_g = $_g + 1;
				#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:55: characters 4-59
				$api = \Type::resolveClass($apiName);
				#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:56: lines 56-57
				if ($api !== null) {
					#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:57: characters 5-19
					$apis->arr[$apis->length] = $api;
					#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:57: characters 5-19
					++$apis->length;
				}
			}
		}
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/api/UFApiContext.hx:59: characters 3-14
		return $apis;
	}


	/**
	 * It is recommended to initialise your UFApiContext using dependency injection.
	 * 
	 * @return void
	 */
	public function __construct () {
	}
}


Boot::registerClass(UFApiContext::class, 'ufront.api.UFApiContext');
