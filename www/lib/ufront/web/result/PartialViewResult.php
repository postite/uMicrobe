<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ da28365)
 * Haxe source file: /Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/result/PartialViewResult.hx
 */

namespace ufront\web\result;

use \php\Boot;
use \ufront\view\_TemplateData\TemplateData_Impl_;
use \php\_Boot\HxAnon;

/**
 * A PartialViewResult is similar to a `ViewResult`, but on the client side it checks checks for partial sections of the view to update, rather than reloading the entire DOM.
 * On the server side, this performs identically to ViewResult.
 * On the client side, this will:
 * 1. Pick the relevant view and layout in the same way as ViewResult.
 * 2. Execute the layout and the template to get a full HTML response.
 * 3. Check the body for a `data-uf-layout` attribute. If the attribute has changed with the new request (that is, the new layout is different to the old one), then the entire body will be replaced.
 * 4. If the layout has not changed, check for elements with a `data-uf-partial` attribute, and replace the old partial element with the new partial element.
 * ### Transition classes
 * - An old partial node that is being replaced will have the `uf-partial-outgoing` class.
 * - A new partial node that is being inserted will initially have the `uf-partial-incoming` class, and it will be removed after 1 millisecond.
 * - You can use these classes to trigger CSS3 transitions.
 * If you would like to prevent your old partial nodes from being deleted before the transitions have completed, you can use a `data-uf-transition-timeout` attribute on the partial node, or set a default value in `PartialViewResult.transitionTimeout`.
 * ### When old and new layouts are different
 * If some of the partial sections in the old body are not in the new body, the sections in the old body will be removed.
 * If some of the partial sections in the new body are not in the old body, they will be ignored.
 * ### Example
 * Imagine this template:
 * ```html
 * <html>
 * <body data-uf-layout="site-page">
 * <div class="container" />
 * <div class="row">
 * <div class="col-md-3">
 * <ul data-uf-partial="nav">
 * ::for (link in navItems)::
 * <li>::link::</li>
 * ::end::
 * </ul>
 * </div>
 * <div class="col-md-9" data-uf-partial="content" data-uf-transition-timeout="1000">
 * ::content::
 * </div>
 * </div>
 * </div>
 * </body>
 * </html>
 * ```
 * When this is executed server-side, it will render the view and the layout as per normal.
 * When it is executed client-side, it will execute the view and the layout, but only replace the DOM nodes for `ul[data-uf-partial=nav]` and `div[data-uf-partial=content]`.
 * The old `content` partial will be given the `uf-partial-outgoing` class, and will be removed when it's CSS animation is complete, or after 1000 milliseconds, whichever occurs first.
 * The new `content` will be created with the `uf-partial-incoming` class, and that class will be removed immediately, allowing a CSS transition to occur.
 * The old `nav` partial will be removed as soon as the new one is ready.
 * If the template and layout that is rendered has a different `body[data-uf-layout]` attribute, then the entire view will be re-rendered.
 */
class PartialViewResult extends ViewResult {
	/**
	 * @var int
	 * The default transitionTimeout value to be used with `js.ufront.web.context.HttpResponse.replaceNode`.
	 * This value will be used if no `data-uf-transition-timeout` attribute is present on the given old partial node.
	 * - If the value is 0 (default), then the old partial nodes will be removed immediately.
	 * - If the value is greater than 0, then the old partial will be removed either when a `transitionend` event occurs, or after the specified number of milliseconds (whichever occurs first).
	 * - If the value is less than 0, then the old partial will only be removed when a `transitionend` event occurs. (Warning: this event is not guaranteed to trigger, as it may have already triggered, may be cancelled etc. It is recommended to use a positive value as a timeout).
	 */
	static public $transitionTimeout = 0;


	/**
	 * A shortcut to create a new PartialViewResult.
	 * This is useful when you are waiting for a Future: `return getFutureContent() >> PartialViewResult.create;`
	 * 
	 * @param object $data
	 * 
	 * @return ViewResult
	 */
	static public function create ($data) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/result/PartialViewResult.hx:95: characters 84-88
		$obj = new HxAnon();
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/result/PartialViewResult.hx:95: characters 84-88
		$this1 = ($obj !== null ? $obj : new HxAnon());
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/result/PartialViewResult.hx:95: characters 54-90
		return new PartialViewResult(TemplateData_Impl_::setObject($this1, $data));
	}


	/**
	 * Add `uf-partial-outgoing` class to each partial section, allowing you to use CSS to style the transitions.
	 * 
	 * @return void
	 */
	static public function startLoadingAnimations () {
	}


	/**
	 * @param object $data
	 * @param string $viewPath
	 * @param object $templatingEngine
	 * 
	 * @return void
	 */
	public function __construct ($data = null, $viewPath = null, $templatingEngine = null) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/result/PartialViewResult.hx:73: lines 73-168
		parent::__construct($data, $viewPath, $templatingEngine);
	}
}


Boot::registerClass(PartialViewResult::class, 'ufront.web.result.PartialViewResult');
