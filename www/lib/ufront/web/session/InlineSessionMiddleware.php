<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ da28365)
 * Haxe source file: /Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/session/InlineSessionMiddleware.hx
 */

namespace ufront\web\session;

use \ufront\core\SurpriseTools;
use \ufront\app\UFMiddleware;
use \ufront\web\context\HttpContext;
use \php\Boot;
use \tink\core\_Future\FutureObject;

/**
 * The `InlineSessionMiddleware` makes sure we `init()` a session before a request starts, and `commit()` it before the request ends.
 * Because these operations are asynchronous, it can be frustrating to deal with in other parts of your web application.
 * Using this middleware allows you to work with the assumption that sessions will be available and ready when you need them.
 * This middleware is included in the default `UfrontConfiguration`.
 * __Always Start?__
 * By default, this middleware will not start a session for a visitor when they first come to your website.
 * The session state will only be initialised if an existing `sessionID` is found - for example, if you set a session ID when they logged in.
 * This way you do not start a session unnecessarily, but after they have logged in, the session will be initialised for each request.
 * This behaviour can be changed by setting `InlineSessionMiddleware.alwaysStart = true`.
 * If `alwaysStart` is true, then a session will be initiated even on the first visit to the website.
 * @author Jason O'Neil
 */
class InlineSessionMiddleware implements UFMiddleware {
	/**
	 * @var bool
	 * Should we start a session for every request, or only if one already exists?
	 * If false, one will only be started if init() is called specifically on one request.
	 * (For example, when they log in).
	 * From there onwards it will initialize with each request.
	 */
	static public $alwaysStart = false;


	/**
	 * @return void
	 */
	public function __construct () {
	}


	/**
	 * Start the session if a SessionID exists in the request, or if `alwaysStart` is true.
	 * 
	 * @param HttpContext $ctx
	 * 
	 * @return FutureObject
	 */
	public function requestIn ($ctx) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/session/InlineSessionMiddleware.hx:47: lines 47-48
		if (InlineSessionMiddleware::$alwaysStart || (($ctx->session->get_id() !== null) && ($ctx->session->get_id() !== ""))) {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/session/InlineSessionMiddleware.hx:47: characters 71-89
			return $ctx->session->init();
		} else {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/session/InlineSessionMiddleware.hx:48: characters 9-32
			return SurpriseTools::success();
		}
	}


	/**
	 * If the session is active and has been used, commit the session before finishing the request.
	 * 
	 * @param HttpContext $ctx
	 * 
	 * @return FutureObject
	 */
	public function responseOut ($ctx) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/session/InlineSessionMiddleware.hx:56: lines 56-57
		if (($ctx->session !== null) && $ctx->session->isReady()) {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/session/InlineSessionMiddleware.hx:56: characters 54-74
			return $ctx->session->commit();
		} else {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/session/InlineSessionMiddleware.hx:57: characters 9-32
			return SurpriseTools::success();
		}
	}
}


Boot::registerClass(InlineSessionMiddleware::class, 'ufront.web.session.InlineSessionMiddleware');
