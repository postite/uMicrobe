<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ da28365)
 * Haxe source file: /Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/session/UFHttpSession.hx
 */

namespace ufront\web\session;

use \php\Boot;
use \tink\core\_Future\FutureObject;
use \php\_Boot\HxAnon;

/**
 * An interface describing an open HTTP session.
 * The methods are similar to `Map`, with `get()`, `set()`, `exists()`, `remove()` and `clear()`.
 * There are also some methods and properties to do with the actual session, not the data inside it: `init()`, `isActive()`, `isReady()`, `id`, `close()`, `commit()`, `regenerateID()` and `setExpiry()`.
 * Using the `UFHttpSession` interface, rather than one of the implementation classes, allows you to write code that can function with a different session implementation.
 * This is useful if you are writing that will be used by multiple apps (perhaps with multiple session implementations), or if you might change your session technology in future.
 * @author Franco Ponticelli
 * @author Jason O'Neil
 */
interface UFHttpSession {
	/**
	 * Empty the session of values.
	 * Please note this does not end the session.
	 * 
	 * @return void
	 */
	public function clear () ;


	/**
	 * Flag the current session for removal.
	 * The session data and session ID should be set to null and when `commit()` is called and the session should be removed from the server.
	 * 
	 * @return void
	 */
	public function close () ;


	/**
	 * Commit the request.
	 * Return a surprise, either notifying you of completion or giving an error message if it failed.
	 * 
	 * @return FutureObject
	 */
	public function commit () ;


	/**
	 * Check if a session value exists.
	 * 
	 * @param string $name
	 * 
	 * @return bool
	 */
	public function exists ($name) ;


	/**
	 * Get an existing session item.
	 * 
	 * @param string $name
	 * 
	 * @return mixed
	 */
	public function get ($name) ;


	/**
	 * @return string
	 */
	public function get_id () ;


	/**
	 * Initiate the session (either read existing or start new session) and prepare so other operations can happen synchronously.
	 * If the session fails to initiate, the Surprise will be a Failure, containing the error message.
	 * @return A Surprise to let you know when the session is ready, after which you can read and modify session data synchronously, until you call `this.commit()`.
	 * 
	 * @return FutureObject
	 */
	public function init () ;


	/**
	 * Return whether or not the session is active, meaning it has been initialised either in this request or in a previous request.
	 * 
	 * @return bool
	 */
	public function isActive () ;


	/**
	 * Return whether or not the session is ready, meaning init() has been called and it is ready to use.
	 * 
	 * @return bool
	 */
	public function isReady () ;


	/**
	 * Request the session ID be regenerated on the next commit.
	 * This will generate a new ID on the server, move the session data to the new ID, and inform the client of the new ID.
	 * If `commit()` is not called, the existing ID will remain.
	 * 
	 * @return void
	 */
	public function regenerateID () ;


	/**
	 * Remove an item from the session.
	 * 
	 * @param string $name
	 * 
	 * @return void
	 */
	public function remove ($name) ;


	/**
	 * Set a session item.
	 * Please note this will not save the session - you must call `commit()` for the change to persist.
	 * 
	 * @param string $name
	 * @param mixed $value
	 * 
	 * @return void
	 */
	public function set ($name, $value) ;


	/**
	 * Set the number of seconds a session should last.
	 * A value of 0 means the session will expire when the browser window is closed.
	 * 
	 * @param int $lifetime
	 * 
	 * @return void
	 */
	public function setExpiry ($lifetime) ;


	/**
	 * Flag this session for a commit.
	 * This will happen automatically if you call `set`, `remove`, `clear`, or `regenerateID`.
	 * Otherwise, this can be useful if a value has updated without `set` being called - for example by pushing a new item to an array that was already in the session.
	 * 
	 * @return void
	 */
	public function triggerCommit () ;
}


Boot::registerClass(UFHttpSession::class, 'ufront.web.session.UFHttpSession');
Boot::registerMeta(UFHttpSession::class, new HxAnon(["obj" => new HxAnon(["interface" => null])]));
Boot::registerGetters('ufront\\web\\session\\UFHttpSession', [
	'id' => true
]);
