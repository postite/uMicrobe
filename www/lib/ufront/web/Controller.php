<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ da28365)
 * Haxe source file: /Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx
 */

namespace ufront\web;

use \haxe\io\Path;
use \ufront\log\MessageType;
use \tink\core\Outcome;
use \ufront\web\context\HttpContext;
use \ufront\web\result\ResultWrapRequired;
use \php\Boot;
use \ufront\web\result\EmptyResult;
use \tink\core\_Future\FutureObject;
use \tink\core\_Future\SyncFuture;
use \haxe\Log;
use \php\_Boot\HxString;
use \php\_Boot\HxAnon;
use \tink\core\_Lazy\LazyConst;
use \ufront\web\result\ActionResult;

/**
 * A Controller ties your Ufront application together - responding to routes, executing certain actions, and returning a result for the client.
 * This class is the base class for any controllers you create in your website or application.
 * Controllers can run on the client or the server, responding to user input, and calling APIs - either directly on the server, or via remoting on the client.
 * They then return a result, describing the output that should be sent to the client.
 * The role of a controller, in Ufront's MVC pattern, includes:
 * - **Routing:**
 * Responding to a request from a client, by looking at `HttpContext.getRequestUri()` and matching it to our `@:route()` metadata.
 * - **Executing Actions:**
 * Each request will execute a method on the controller (sometimes called an "Action").
 * This method can validate or transform user input, interact with APIs, and prepare a result.
 * It is recommended to keep your filesystem access, DB access, or security focused application logic in a `UFApi` rather than a Controller.
 * This guarantees your code to run on the server and not the client, and keeps it safe from tampering.
 * - **Returning a result:**
 * Each controller will return a result.
 * This can be an `ActionResult`, a `FutureActionResult`, an `ActionOutcome` or a `FutureActionOutcome`.
 * Any return type that does not fit this pattern - for example, returning a String, or even returning Void - will be wrapped in one of these result types.
 * Ufront's `MVCHandler` will then take the result returned by the controller and execute it, writing the output to the `HttpResponse`.
 * Each of these steps is described in more detail below.
 * ### Routing
 * When you app executes, it tries to match the URI of the `HttpRequest` with the routes on your controller.
 * Each controller has a macro generated `execute()` method, which goes through the fields of the controller looking for matching `@:route()` metadata.
 * When it finds a route which matches the current URI, it executes the method/action for that route.
 * Routing always begins with the Controller you set in `UfrontConfiguration.indexController`, and can drill down into any sub controllers from there.
 * You set up an action by defining a function and giving it `@:route` metadata.
 * You can also use `@:route` metadata on a variable which holds a sub-controller.
 * Here are some examples:
 * ```
 * @:route('/') function homepage() {}
 * @:route('/staff/') function staff() {}
 * @:route('/staff/$name/') function viewPerson( name:String ) {}
 * @:route('/staff/$name/contact/',GET) function contact( name:String ) {}
 * @:route('/staff/$name/contact/',POST) function contact( name:String, args:{ subject:String, text:String } ) {}
 * @:route('/article/$name/$page/') function article( name:String, page:Int ) {}
 * @:route('/file/*') function viewFile( parts:Array<String> ) {}
 * @:route('/ufadmin/*') var adminController:UFAdminHomeController;
 * ```
 * ### Executing Actions
 * Once a matching route has been found, your controller will execute the given action.
 * - *If the action was a sub-controller variable*, it will call `this.executeSubController()` for the given controller, and return the result.
 * - *If the action was a method*, it will gather the function arguments based on the `HttpRequest`, and execute the function, and return the result.
 * - In your controller actions you have access to the current `this.context:HttpContext`, which allows you to read data from the request and add items to the response.
 * - Controllers also have dependency injection available to them - you can inject whatever you need, especially any `UFApi` classes you plan to use.
 * - If you would like to trace output, each controller has private `ufTrace()`, `ufLog()`, `ufWarn()` and `ufError()` methods, which will send output to your `UFLogHandler`s.
 * - Your function should return a result, which will define what content is sent to the client. See the section below for details.
 * > **Note:** It is wise to do most of the "heavy lifting" of your app in a `UFApi`, which you call from the controller, rather than in a controller directly.
 * >
 * > Some web frameworks prefer you to include most of your application logic in your controller actions.
 * > However, Ufront controllers can run on the server or on the client - which means our controllers cannot assume access to system resources (for example, a database), and they cannot be trusted with sensitive code, because they run client side and are open to inspection or modification.
 * >
 * > For this reason, we recommend that anything to do with database connections, file systems, permission checks or sensitive application logic, be kept on the server and called through a `UFApi`.
 * ### Returning a Result
 * Each controller action returns a result of some kind - and these results are how we control what response gets written to the browser.
 * Possible return values are:
 * - `Surprise<ActionResult,tink.core.Error>`
 * - `Surprise<Dynamic,Dynamic>`
 * - `Future<ActionResult>`
 * - `Future<Dynamic>`
 * - `Outcome<ActionResult,tink.core.Error>`
 * - `Outcome<Dynamic,Dynamic>`
 * - `ActionResult`
 * - `Dynamic`
 * - `Void`
 * No matter what the return type of your action is, when `execute is called` it will be appropriately wrapped into a `FutureActionOutcome` (which is really a `Future<Outcome<ActionResult,Error>>`).
 * Assuming the result was successful, there will be a valid `ActionResult` that the `MVCHandler` in your application will be able to execute, and this is what writes content to the browser.
 * Action results are designed to be easy to work with.
 * For example:
 * - `return new ViewResult({ title:"Ufront", subtitle:"Community" });`
 * - `return new JsonResult({ title:"Ufront", subtitle:"Community" });`
 * - `return new RedirectResult("http://haxe.org");`
 * - `return new FilePathResult(context.contentDirectory+"my-upload.jpg");`
 * See `ActionResult` and each of the sub-classes for a complete list of result types provided, or for information on creating your own.
 * > **Note:** It is recommended to use an `ActionResult` rather than using `Sys.println()` or `HttpResponse.write()` directly.
 * >
 * > Not only are these more convenient, they are easier to write unit tests for, and allow the app to show error pages gracefully when required.
 * ### The Build Macro (or, "How This Actually Works")
 * The `this.execute()` method on this class is abstract, and will always be overridden on each child class.
 * The build macro will build a custom execute field for each controller based on that controller's `@:route()` metadata.
 * The execute function that is generated is essentially a giant `if / else if / else` chain:
 * ```haxe
 * class HomeController extends Controller {
 * @:route("/") function index() return "Homepage!";
 * @:route("/contact",GET) function contactForm() return "Contact form!";
 * @:route("/contact",POST) function contactSend() return "Email sent!";
 * override public function execute() {
 * if ( uri=="/" ) return index();
 * else if ( uri=="/contact/" && method=="GET" ) return contactForm();
 * else if ( uri=="/contact/" && method=="POST" ) return contactSend();
 * else throw HttpError.pageNotFound();
 * }
 * }
 * ```
 * It is of course slightly more complex than this, and involves calling some private functions to ensure we have a consistent return type of `FutureActionOutcome`.
 * But knowing this is the basic structure of the execute method can be helpful.
 * If you ever want to check the exact details, compile your code with `-D dump=pretty` to get the Haxe compiler to show you the code output of the macros.
 * The `execute()` method will test each route in the order they are defined.
 * So if you have a wildcard route `@:route("/*")`  at the top of your class, and a specific route `@:route('/mypage/')` below it, the wildcard will match first and be called every time.
 * If the build macro encounters `@:route()` metadata on a variable rather than a method, it will:
 * - Check the given variable's type represents a `Controller`.
 * - Create a method: `function execute_$varName() return executeSubController(context);`
 * - Perform the routing on the generated function.
 * The build macro does not effect any existing fields other than `this.execute()`.
 */
class Controller {


	/**
	 * @var string
	 * The Base URI that was used to access this controller.
	 * This is the URL after filters have been processed, as it is used for routing.
	 * This will always begin with `~/` indicating that it is a relative URL, and will be transformed if you have URL filters and use it in a `ViewResult`, `ContentResult`, `RedirectResult` or `DetoxResult`.
	 * This will always include a trailing slash.
	 * For example if you had `/user/profile/jason/` trigger `UserController` and the `profile` action for "jason", then baseUri would be `~/user/`.
	 * This is set during `injectContext()`, before any routing occurs.
	 */
	public $baseUri;
	/**
	 * @var HttpContext
	 * The current HttpContext.
	 * This is set via dependency injection in the `injectContext()` method.
	 * If you want to run some code after this has been injected, but before routing occurs, you can use `@post`.
	 * For example:
	 * ```
	 * @post public function doAuthCheck() {
	 * context.auth.requirePermission(AccessAdminArea);
	 * }
	 * ```
	 */
	public $context;


	/**
	 * Create a new `Controller` instance.
	 * In Ufront controllers are usually created through dependency injection, so you can use `@inject` metadata on your sub-controller constructors.
	 * If creating a controller manually, rather than via dependency injection, be sure to inject the dependencies (such as `context`) manually.
	 * 
	 * @return void
	 */
	public function __construct () {
	}


	/**
	 * Execute this controller using the current `HttpContext`.
	 * This will anazlyze the URI and the current `HttpRequest`, and match it to the appropriate action using the `@:route()` metadata.
	 * It will wrap the return result of your action in a `Surprise<ActionResult,tink.core.Error>`.
	 * Please note this is an abstract method.
	 * Each controller that extends `ufront.web.Controller` will have an override, provided by a build macro, that has the appropriate code for that class.
	 * 
	 * @return FutureObject
	 */
	public function execute () {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:219: characters 10-172
		return new SyncFuture(new LazyConst(Outcome::Failure(HttpError::internalServerError("Field execute() in ufront.web.Controller is an abstract method, please override it in " . ($this->toString()??'null') . " ", null, new HxAnon([
			"fileName" => "ufront/web/Controller.hx",
			"lineNumber" => 219,
			"className" => "ufront.web.Controller",
			"methodName" => "execute",
		])))));
	}


	/**
	 * Instantiate and execute a sub controller.
	 * 
	 * @param Class $controller
	 * 
	 * @return FutureObject
	 */
	public function executeSubController ($controller) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:226: characters 3-62
		return $this->context->injector->_instantiate($controller)->execute();
	}


	/**
	 * Inject the HttpContext and set `baseUri`.
	 * 
	 * @param HttpContext $context
	 * 
	 * @return void
	 */
	public function injectContext ($context) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:201: characters 3-25
		$this->context = $context;
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:202: characters 3-62
		$uriPartsBeforeRouting = $context->actionContext->get_uriParts();
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:203: characters 3-75
		$remainingUri = Path::addTrailingSlash($uriPartsBeforeRouting->join("/"));
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:204: characters 3-60
		$fullUri = Path::addTrailingSlash($context->getRequestUri());
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:205: characters 3-98
		$this->baseUri = "~" . (Path::addTrailingSlash(HxString::substr($fullUri, 0, strlen($fullUri) - strlen($remainingUri)))??'null');
	}


	/**
	 * A helper to set context.actionResult once the result of execute() has finished loading.
	 * 
	 * @param FutureObject $result
	 * 
	 * @return void
	 */
	public function setContextActionResultWhenFinished ($result) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:314: lines 314-319
		$_gthis = $this;
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:315: lines 315-318
		$result->handle(function ($outcome)  use (&$_gthis) {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:315: lines 315-318
			if ($outcome->index === 0) {
				#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:316: characters 17-19
				$ar = $outcome->params[0];
				#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:316: characters 22-61
				$_gthis->context->actionContext->actionResult = $ar;
			}
		});
	}


	/**
	 * A default toString() that prints the current class name.
	 * This is useful primarily for logging requests and knowing which controller was called.
	 * 
	 * @return string
	 */
	public function toString () {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:235: characters 3-50
		return \Type::getClassName(\Type::getClass($this));
	}


	/**
	 * A shortcut to `context.ufError()`
	 * 
	 * @param mixed $msg
	 * @param object $pos
	 * 
	 * @return void
	 */
	public function ufError ($msg, $pos = null) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:270: lines 270-271
		if ($this->context !== null) {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:270: characters 22-49
			$_this = $this->context->messages;
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:270: characters 22-49
			$_this->arr[$_this->length] = new HxAnon([
				"msg" => $msg,
				"pos" => $pos,
				"type" => MessageType::MError(),
			]);
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:270: characters 22-49
			++$_this->length;
		} else {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:271: characters 8-44
			(Log::$trace)("Error: " . (\Std::string($msg)??'null'), $pos);
		}
	}


	/**
	 * A shortcut to `context.ufLog()`
	 * 
	 * @param mixed $msg
	 * @param object $pos
	 * 
	 * @return void
	 */
	public function ufLog ($msg, $pos = null) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:252: lines 252-253
		if ($this->context !== null) {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:252: characters 22-47
			$_this = $this->context->messages;
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:252: characters 22-47
			$_this->arr[$_this->length] = new HxAnon([
				"msg" => $msg,
				"pos" => $pos,
				"type" => MessageType::MLog(),
			]);
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:252: characters 22-47
			++$_this->length;
		} else {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:253: characters 8-42
			(Log::$trace)("Log: " . (\Std::string($msg)??'null'), $pos);
		}
	}


	/**
	 * A shortcut to `context.ufTrace()`
	 * 
	 * @param mixed $msg
	 * @param object $pos
	 * 
	 * @return void
	 */
	public function ufTrace ($msg, $pos = null) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:243: lines 243-244
		if ($this->context !== null) {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:243: characters 22-49
			$_this = $this->context->messages;
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:243: characters 22-49
			$_this->arr[$_this->length] = new HxAnon([
				"msg" => $msg,
				"pos" => $pos,
				"type" => MessageType::MTrace(),
			]);
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:243: characters 22-49
			++$_this->length;
		} else {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:244: characters 8-37
			(Log::$trace)("" . (\Std::string($msg)??'null'), $pos);
		}
	}


	/**
	 * A shortcut to `context.ufWarn()`
	 * 
	 * @param mixed $msg
	 * @param object $pos
	 * 
	 * @return void
	 */
	public function ufWarn ($msg, $pos = null) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:261: lines 261-262
		if ($this->context !== null) {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:261: characters 22-48
			$_this = $this->context->messages;
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:261: characters 22-48
			$_this->arr[$_this->length] = new HxAnon([
				"msg" => $msg,
				"pos" => $pos,
				"type" => MessageType::MWarning(),
			]);
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:261: characters 22-48
			++$_this->length;
		} else {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:262: characters 8-46
			(Log::$trace)("Warning: " . (\Std::string($msg)??'null'), $pos);
		}
	}


	/**
	 * A helper to wrap a return result in a Future
	 * 
	 * @param mixed $result
	 * 
	 * @return FutureObject
	 */
	public function wrapInFuture ($result) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:294: characters 3-31
		return new SyncFuture(new LazyConst($result));
	}


	/**
	 * A helper to wrap a return result in a Future
	 * 
	 * @param FutureObject $future
	 * 
	 * @return FutureObject
	 */
	public function wrapInOutcome ($future) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:300: characters 10-65
		$ret = $future->map(function ($result) {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:300: characters 39-63
			return Outcome::Success($result);
		});
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:300: characters 10-65
		return $ret->gather();
	}


	/**
	 * Based on a set of enum flags, wrap as required.  If null, return an appropriately wrapped EmptyResult()
	 * 
	 * @param mixed $result
	 * @param int $wrappingRequired
	 * 
	 * @return FutureObject
	 */
	public function wrapResult ($result, $wrappingRequired) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:279: lines 279-288
		if ($result === null) {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:280: characters 4-60
			$actionResult = new EmptyResult(true);
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:281: characters 11-47
			return new SyncFuture(new LazyConst(Outcome::Success($actionResult)));
		} else {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:284: characters 4-103
			$future = (($wrappingRequired & (1 << Boot::dynamicField(ResultWrapRequired::WRFuture(), 'index'))) !== 0 ? $this->wrapInFuture($result) : $result);
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:285: characters 4-117
			$surprise = (($wrappingRequired & (1 << Boot::dynamicField(ResultWrapRequired::WROutcome(), 'index'))) !== 0 ? $this->wrapInOutcome($future) : $future);
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:286: characters 4-137
			$finalResult = (($wrappingRequired & (1 << Boot::dynamicField(ResultWrapRequired::WRResultOrError(), 'index'))) !== 0 ? $this->wrapResultOrError($surprise) : $surprise);
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:287: characters 4-22
			return $finalResult;
		}
	}


	/**
	 * A helper to wrap a return result in a Future
	 * 
	 * @param FutureObject $surprise
	 * 
	 * @return FutureObject
	 */
	public function wrapResultOrError ($surprise) {
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:306: lines 306-309
		$ret = $surprise->map(function ($outcome) {
			#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:306: lines 306-309
			switch ($outcome->index) {
				case 0:
					#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:307: characters 17-23
					$result = $outcome->params[0];
					#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:307: characters 26-62
					return Outcome::Success(ActionResult::wrap($result));
					break;
				case 1:
					#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:308: characters 17-22
					$error = $outcome->params[0];
					#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:308: characters 25-57
					return Outcome::Failure(HttpError::wrap($error, null, new HxAnon([
						"fileName" => "ufront/web/Controller.hx",
						"lineNumber" => 308,
						"className" => "ufront.web.Controller",
						"methodName" => "wrapResultOrError",
					])));
					break;
			}
		});
		#/Users/ut/Documents/LAB/ufront-mvc/src/ufront/web/Controller.hx:306: lines 306-309
		return $ret->gather();
	}


	public function __toString() {
		return $this->toString();
	}


	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


	}
}


Boot::registerClass(Controller::class, 'ufront.web.Controller');
Boot::registerMeta(Controller::class, new HxAnon(["obj" => new HxAnon(["rtti" => \Array_hx::wrap([\Array_hx::wrap([
	"injectContext",
	"",
	"ufront.web.context.HttpContext",
	"",
	"",
])])])]));
Controller::__hx__init();
