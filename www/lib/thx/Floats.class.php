<?php

// Generated by Haxe 3.4.7
class thx_Floats {
	public function __construct(){}
	static $TOLERANCE = 10e-5;
	static $EPSILON = 1e-9;
	static $pattern_parse;
	static function angleDifference($a, $b, $turn = null) {
		$GLOBALS['%s']->push("thx.Floats::angleDifference");
		$__hx__spos = $GLOBALS['%s']->length;
		if($turn === null) {
			$turn = 360.0;
		}
		$r = _hx_mod(($b - $a), $turn);
		if($r < 0) {
			$r = $r + $turn;
		}
		if($r > $turn / 2) {
			$r = $r - $turn;
		}
		{
			$GLOBALS['%s']->pop();
			return $r;
		}
		$GLOBALS['%s']->pop();
	}
	static function ceilTo($f, $decimals) {
		$GLOBALS['%s']->push("thx.Floats::ceilTo");
		$__hx__spos = $GLOBALS['%s']->length;
		$p = Math::pow(10, $decimals);
		{
			$tmp = Math::fceil($f * $p) / $p;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function canParse($s) {
		$GLOBALS['%s']->push("thx.Floats::canParse");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = thx_Floats::$pattern_parse->match($s);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function clamp($v, $min, $max) {
		$GLOBALS['%s']->push("thx.Floats::clamp");
		$__hx__spos = $GLOBALS['%s']->length;
		if($v < $min) {
			$GLOBALS['%s']->pop();
			return $min;
		} else {
			if($v > $max) {
				$GLOBALS['%s']->pop();
				return $max;
			} else {
				$GLOBALS['%s']->pop();
				return $v;
			}
		}
		$GLOBALS['%s']->pop();
	}
	static function clampSym($v, $max) {
		$GLOBALS['%s']->push("thx.Floats::clampSym");
		$__hx__spos = $GLOBALS['%s']->length;
		$min = -$max;
		if($v < $min) {
			$GLOBALS['%s']->pop();
			return $min;
		} else {
			if($v > $max) {
				$GLOBALS['%s']->pop();
				return $max;
			} else {
				$GLOBALS['%s']->pop();
				return $v;
			}
		}
		$GLOBALS['%s']->pop();
	}
	static function compare($a, $b) {
		$GLOBALS['%s']->push("thx.Floats::compare");
		$__hx__spos = $GLOBALS['%s']->length;
		if($a < $b) {
			$GLOBALS['%s']->pop();
			return -1;
		} else {
			if($a > $b) {
				$GLOBALS['%s']->pop();
				return 1;
			} else {
				$GLOBALS['%s']->pop();
				return 0;
			}
		}
		$GLOBALS['%s']->pop();
	}
	static function floorTo($f, $decimals) {
		$GLOBALS['%s']->push("thx.Floats::floorTo");
		$__hx__spos = $GLOBALS['%s']->length;
		$p = Math::pow(10, $decimals);
		{
			$tmp = Math::ffloor($f * $p) / $p;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function interpolate($f, $a, $b) {
		$GLOBALS['%s']->push("thx.Floats::interpolate");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = ($b - $a) * $f + $a;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function interpolateAngle($f, $a, $b, $turn = null) {
		$GLOBALS['%s']->push("thx.Floats::interpolateAngle");
		$__hx__spos = $GLOBALS['%s']->length;
		if($turn === null) {
			$turn = 360;
		}
		{
			$tmp = thx_Floats::wrapCircular(thx_Floats::interpolate($f, $a, $a + thx_Floats::angleDifference($a, $b, $turn)), $turn);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function interpolateAngleWidest($f, $a, $b, $turn = null) {
		$GLOBALS['%s']->push("thx.Floats::interpolateAngleWidest");
		$__hx__spos = $GLOBALS['%s']->length;
		if($turn === null) {
			$turn = 360;
		}
		{
			$tmp = thx_Floats::wrapCircular(thx_Floats::interpolateAngle($f, $a, $b, $turn) - $turn / 2, $turn);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function interpolateAngleCW($f, $a, $b, $turn = null) {
		$GLOBALS['%s']->push("thx.Floats::interpolateAngleCW");
		$__hx__spos = $GLOBALS['%s']->length;
		if($turn === null) {
			$turn = 360;
		}
		$a = thx_Floats::wrapCircular($a, $turn);
		$b = thx_Floats::wrapCircular($b, $turn);
		if($b < $a) {
			$b = $b + $turn;
		}
		{
			$tmp = thx_Floats::wrapCircular(thx_Floats::interpolate($f, $a, $b), $turn);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function interpolateAngleCCW($f, $a, $b, $turn = null) {
		$GLOBALS['%s']->push("thx.Floats::interpolateAngleCCW");
		$__hx__spos = $GLOBALS['%s']->length;
		if($turn === null) {
			$turn = 360;
		}
		$a = thx_Floats::wrapCircular($a, $turn);
		$b = thx_Floats::wrapCircular($b, $turn);
		if($b > $a) {
			$b = $b - $turn;
		}
		{
			$tmp = thx_Floats::wrapCircular(thx_Floats::interpolate($f, $a, $b), $turn);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function max($a, $b) {
		$GLOBALS['%s']->push("thx.Floats::max");
		$__hx__spos = $GLOBALS['%s']->length;
		if($a > $b) {
			$GLOBALS['%s']->pop();
			return $a;
		} else {
			$GLOBALS['%s']->pop();
			return $b;
		}
		$GLOBALS['%s']->pop();
	}
	static function min($a, $b) {
		$GLOBALS['%s']->push("thx.Floats::min");
		$__hx__spos = $GLOBALS['%s']->length;
		if($a < $b) {
			$GLOBALS['%s']->pop();
			return $a;
		} else {
			$GLOBALS['%s']->pop();
			return $b;
		}
		$GLOBALS['%s']->pop();
	}
	static function nearEquals($a, $b, $tollerance = null) {
		$GLOBALS['%s']->push("thx.Floats::nearEquals");
		$__hx__spos = $GLOBALS['%s']->length;
		if($tollerance === null) {
			$tollerance = 1e-9;
		}
		if(Math::isFinite($a)) {
			if(!Math::isFinite($b)) {
				$GLOBALS['%s']->pop();
				return false;
			}
			{
				$tmp = Math::abs($a - $b) <= $tollerance;
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}
		if(Math::isNaN($a)) {
			$tmp = Math::isNaN($b);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		if(Math::isNaN($b)) {
			$GLOBALS['%s']->pop();
			return false;
		}
		if(!Math::isFinite($b)) {
			$tmp = (is_object($_t = ($a > 0)) && ($_t instanceof Enum) ? $_t == $b > 0 : _hx_equal($_t, $b > 0));
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		{
			$GLOBALS['%s']->pop();
			return false;
		}
		$GLOBALS['%s']->pop();
	}
	static function nearEqualAngles($a, $b, $turn = null, $tollerance = null) {
		$GLOBALS['%s']->push("thx.Floats::nearEqualAngles");
		$__hx__spos = $GLOBALS['%s']->length;
		if($tollerance === null) {
			$tollerance = 1e-9;
		}
		if($turn === null) {
			$turn = 360.0;
		}
		{
			$tmp = Math::abs(thx_Floats::angleDifference($a, $b, $turn)) <= $tollerance;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function nearZero($n, $tollerance = null) {
		$GLOBALS['%s']->push("thx.Floats::nearZero");
		$__hx__spos = $GLOBALS['%s']->length;
		if($tollerance === null) {
			$tollerance = 1e-9;
		}
		{
			$tmp = Math::abs($n) <= $tollerance;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function normalize($v) {
		$GLOBALS['%s']->push("thx.Floats::normalize");
		$__hx__spos = $GLOBALS['%s']->length;
		if($v < 0) {
			$GLOBALS['%s']->pop();
			return 0;
		} else {
			if($v > 1) {
				$GLOBALS['%s']->pop();
				return 1;
			} else {
				$GLOBALS['%s']->pop();
				return $v;
			}
		}
		$GLOBALS['%s']->pop();
	}
	static function parse($s) {
		$GLOBALS['%s']->push("thx.Floats::parse");
		$__hx__spos = $GLOBALS['%s']->length;
		if(_hx_substring($s, 0, 1) === "+") {
			$s = _hx_substring($s, 1, null);
		}
		{
			$tmp = Std::parseFloat($s);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function root($base, $index) {
		$GLOBALS['%s']->push("thx.Floats::root");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = Math::pow($base, 1 / $index);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function roundTo($f, $decimals) {
		$GLOBALS['%s']->push("thx.Floats::roundTo");
		$__hx__spos = $GLOBALS['%s']->length;
		$p = Math::pow(10, $decimals);
		{
			$tmp = Math::fround($f * $p) / $p;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function sign($value) {
		$GLOBALS['%s']->push("thx.Floats::sign");
		$__hx__spos = $GLOBALS['%s']->length;
		if($value < 0) {
			$GLOBALS['%s']->pop();
			return -1;
		} else {
			$GLOBALS['%s']->pop();
			return 1;
		}
		$GLOBALS['%s']->pop();
	}
	static function toString($v) {
		$GLOBALS['%s']->push("thx.Floats::toString");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = "" . _hx_string_rec($v, "");
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function toFloat($s) {
		$GLOBALS['%s']->push("thx.Floats::toFloat");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = thx_Floats::parse($s);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function trunc($value) {
		$GLOBALS['%s']->push("thx.Floats::trunc");
		$__hx__spos = $GLOBALS['%s']->length;
		if($value < 0.0) {
			$tmp = Math::ceil($value);
			$GLOBALS['%s']->pop();
			return $tmp;
		} else {
			$tmp = Math::floor($value);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function ftrunc($value) {
		$GLOBALS['%s']->push("thx.Floats::ftrunc");
		$__hx__spos = $GLOBALS['%s']->length;
		if($value < 0.0) {
			$tmp = Math::fceil($value);
			$GLOBALS['%s']->pop();
			return $tmp;
		} else {
			$tmp = Math::ffloor($value);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function wrap($v, $min, $max) {
		$GLOBALS['%s']->push("thx.Floats::wrap");
		$__hx__spos = $GLOBALS['%s']->length;
		$range = $max - $min + 1;
		if($v < $min) {
			$v = $v + $range * (($min - $v) / $range + 1);
		}
		{
			$tmp = $min + _hx_mod(($v - $min), $range);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	static function wrapCircular($v, $max) {
		$GLOBALS['%s']->push("thx.Floats::wrapCircular");
		$__hx__spos = $GLOBALS['%s']->length;
		$v = _hx_mod($v, $max);
		if($v < 0) {
			$v = $v + $max;
		}
		{
			$GLOBALS['%s']->pop();
			return $v;
		}
		$GLOBALS['%s']->pop();
	}
	static function order() { $args = func_get_args(); return call_user_func_array(self::$order, $args); }
	static $order;
	static $monoid;
	function __toString() { return 'thx.Floats'; }
}
thx_Floats::$pattern_parse = new EReg("^(\\+|-)?\\d+(\\.\\d+)?(e-?\\d+)?\$", "");
thx_Floats::$order = thx__Ord_Ord_Impl_::fromIntComparison((property_exists("thx_Floats", "compare") ? thx_Floats::$compare: array("thx_Floats", "compare")));
thx_Floats::$monoid = _hx_anonymous(array("zero" => 0.0, "append" => array(new _hx_lambda(array(), "thx_Floats_0"), 'execute')));
function thx_Floats_0($a, $b) {
	{
		$GLOBALS['%s']->push("thx.Floats::wrapCircular@248");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = $a + $b;
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
}
