<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ da28365)
 * Haxe source file: /usr/local/lib/haxe/std/php/_std/Sys.hx
 */

use \php\_Boot\HxClosure;
use \sys\io\FileInput;
use \haxe\io\Output;
use \haxe\ds\StringMap;
use \php\Boot;
use \haxe\io\Input;
use \php\_Boot\HxString;
use \php\Lib;
use \sys\io\FileOutput;

/**
 * This class gives you access to many base functionalities of system platforms. Looks in `sys` sub packages for more system APIs.
 */
class Sys {
	/**
	 * @var string
	 */
	static public $_programPath;
	/**
	 * @var mixed
	 * Environment variables set by `Sys.putEnv()`
	 */
	static public $customEnvVars;


	/**
	 * Returns all the arguments that were passed by the command line.
	 * 
	 * @return \Array_hx
	 */
	static public function args () {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:40: lines 40-44
		if (array_key_exists("argv", $_SERVER)) {
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:41: characters 4-89
			return \Array_hx::wrap(array_slice($_SERVER["argv"], 1));
		} else {
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:43: characters 4-13
			return new \Array_hx();
		}
	}


	/**
	 * Run the given command. The command output will be printed on the same output as the current process.
	 * The current process will block until the command terminates and it will return the command result (0 if there was no error).
	 * Command arguments can be passed in two ways: 1. using `args`, 2. appending to `cmd` and leaving `args` as `null`.
	 * 1. When using `args` to pass command arguments, each argument will be automatically quoted, and shell meta-characters will be escaped if needed.
	 * `cmd` should be an executable name that can be located in the `PATH` environment variable, or a path to an executable.
	 * 2. When `args` is not given or is `null`, command arguments can be appended to `cmd`. No automatic quoting/escaping will be performed. `cmd` should be formatted exactly as it would be when typed at the command line.
	 * It can run executables, as well as shell commands that are not executables (e.g. on Windows: `dir`, `cd`, `echo` etc).
	 * Read the `sys.io.Process` api for a more complete way to start background processes.
	 * 
	 * @param string $cmd
	 * @param \Array_hx $args
	 * 
	 * @return int
	 */
	static public function command ($cmd, $args = null) {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:83: lines 83-93
		if ($args !== null) {
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:84: characters 12-24
			$_g = Sys::systemName();
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:84: characters 12-24
			if ($_g === "Windows") {
				#/usr/local/lib/haxe/std/php/_std/Sys.hx:86: lines 86-89
				$_g1 = new \Array_hx();
				#/usr/local/lib/haxe/std/php/_std/Sys.hx:87: lines 87-88
				$_g11 = 0;
				#/usr/local/lib/haxe/std/php/_std/Sys.hx:87: lines 87-88
				$_g2 = (\Array_hx::wrap([\StringTools::replace($cmd, "/", "\\")]))->concat($args);
				#/usr/local/lib/haxe/std/php/_std/Sys.hx:87: lines 87-88
				while ($_g11 < $_g2->length) {
					#/usr/local/lib/haxe/std/php/_std/Sys.hx:87: characters 12-13
					$a = ($_g2->arr[$_g11] ?? null);
					#/usr/local/lib/haxe/std/php/_std/Sys.hx:87: lines 87-88
					$_g11 = $_g11 + 1;
					#/usr/local/lib/haxe/std/php/_std/Sys.hx:88: characters 7-39
					$x = \StringTools::quoteWinArg($a, true);
					#/usr/local/lib/haxe/std/php/_std/Sys.hx:88: characters 7-39
					$_g1->arr[$_g1->length] = $x;
					#/usr/local/lib/haxe/std/php/_std/Sys.hx:88: characters 7-39
					++$_g1->length;

				}

				#/usr/local/lib/haxe/std/php/_std/Sys.hx:86: lines 86-89
				$cmd = $_g1->join(" ");
			} else {
				#/usr/local/lib/haxe/std/php/_std/Sys.hx:91: characters 12-60
				$_this = (\Array_hx::wrap([$cmd]))->concat($args);
				#/usr/local/lib/haxe/std/php/_std/Sys.hx:91: characters 12-60
				$f = new HxClosure(\StringTools::class, 'quoteUnixArg');
				#/usr/local/lib/haxe/std/php/_std/Sys.hx:91: characters 12-60
				$result = [];
				#/usr/local/lib/haxe/std/php/_std/Sys.hx:91: characters 12-60
				$_g12 = 0;
				#/usr/local/lib/haxe/std/php/_std/Sys.hx:91: characters 12-60
				$_g3 = $_this->length;
				#/usr/local/lib/haxe/std/php/_std/Sys.hx:91: characters 12-60
				while ($_g12 < $_g3) {
					#/usr/local/lib/haxe/std/php/_std/Sys.hx:91: characters 12-60
					$_g12 = $_g12 + 1;
					#/usr/local/lib/haxe/std/php/_std/Sys.hx:91: characters 12-60
					$i = $_g12 - 1;
					#/usr/local/lib/haxe/std/php/_std/Sys.hx:91: characters 12-60
					$result[] = $f($_this->arr[$i]);
				}

				#/usr/local/lib/haxe/std/php/_std/Sys.hx:91: characters 6-70
				$cmd = \Array_hx::wrap($result)->join(" ");
			}
		}
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:94: characters 3-30
		$result1 = Boot::deref(0);
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:95: characters 3-29
		system($cmd, $result1);
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:96: characters 3-16
		return $result1;
	}


	/**
	 * Gives the most precise timestamp value (in seconds) but only account for the actual time spent running on the CPU for the current thread/process.
	 * 
	 * @return float
	 */
	static public function cpuTime () {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:108: characters 3-54
		return microtime(true) - $_SERVER["REQUEST_TIME"];
	}


	/**
	 * Returns all environment variables.
	 * 
	 * @return StringMap
	 */
	static public function environment () {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:122: characters 3-33
		$env = $_SERVER;
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:123: lines 123-125
		foreach ((Sys::$customEnvVars) as $name => $value) {
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:124: characters 4-21
			$env[$name] = $value;
		};
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:126: characters 3-45
		return Lib::hashOfAssociativeArray($env);
	}


	/**
	 * Returns the path to the current executable that we are running.
	 * 
	 * @return string
	 */
	static public function executablePath () {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:112: characters 10-48
		return $_SERVER["SCRIPT_FILENAME"];
	}


	/**
	 * Exit the current process with the given error code.
	 * 
	 * @param int $code
	 * 
	 * @return void
	 */
	static public function exit ($code) {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:100: characters 3-20
		exit($code);
	}


	/**
	 * Read a single input character from the standard input and returns it. Setting `echo` to true will also display it on the output.
	 * 
	 * @param bool $echo
	 * 
	 * @return int
	 */
	static public function getChar ($echo) {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:145: characters 3-37
		$c = fgetc(STDIN);
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:146: lines 146-151
		if ($c === false) {
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:147: characters 4-12
			return 0;
		} else {
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:149: characters 4-27
			if ($echo) {
				#/usr/local/lib/haxe/std/php/_std/Sys.hx:149: characters 13-27
				echo($c);
			}
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:150: characters 4-24
			return ord($c);
		}
	}


	/**
	 * Get the current working directory (usually the one in which the program was started)
	 * 
	 * @return string
	 */
	static public function getCwd () {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:66: characters 3-29
		$cwd = getcwd();
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:67: characters 3-32
		if ($cwd === false) {
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:67: characters 21-32
			return null;
		}
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:68: characters 3-35
		$l = HxString::substr($cwd, -1);
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:69: characters 3-59
		return ($cwd??'null') . (((($l === "/") || ($l === "\\") ? "" : "/"))??'null');
	}


	/**
	 * Returns the value of the given environment variable.
	 * 
	 * @param string $s
	 * 
	 * @return string
	 */
	static public function getEnv ($s) {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:48: characters 3-32
		$value = getenv($s);
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:49: characters 10-39
		if ($value === false) {
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:49: characters 27-31
			return null;
		} else {
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:49: characters 34-39
			return $value;
		}
	}


	/**
	 * Print any value on the standard output.
	 * 
	 * @param mixed $v
	 * 
	 * @return void
	 */
	static public function print ($v) {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:32: characters 3-29
		echo(\Std::string($v));
	}


	/**
	 * Print any value on the standard output, followed by a newline.
	 * 
	 * @param mixed $v
	 * 
	 * @return void
	 */
	static public function println ($v) {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:36: characters 3-36
		echo((\Std::string($v)??'null') . "\x0A");
	}


	/**
	 * Returns the absolute path to the current program file that we are running.
	 * Concretely, for an executable binary, it returns the path to the binary.
	 * For a script (e.g. a PHP file), it returns the path to the script.
	 * 
	 * @return string
	 */
	static public function programPath () {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:118: characters 3-22
		return Sys::$_programPath;
	}


	/**
	 * Set the value of the given environment variable.
	 * 
	 * @param string $s
	 * @param string $v
	 * 
	 * @return void
	 */
	static public function putEnv ($s, $v) {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:53: characters 3-26
		Sys::$customEnvVars[$s] = "" . ($v??'null');
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:54: characters 3-25
		putenv("" . ($s??'null') . "=" . ($v??'null'));
	}


	/**
	 * Change the current working directory.
	 * 
	 * @param string $s
	 * 
	 * @return void
	 */
	static public function setCwd ($s) {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:73: characters 3-18
		chdir($s);
	}


	/**
	 * Change the current time locale, which will affect `DateTools.format` date formating.
	 * Returns true if the locale was successfully changed
	 * 
	 * @param string $loc
	 * 
	 * @return bool
	 */
	static public function setTimeLocale ($loc) {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:62: characters 3-55
		return setlocale(LC_TIME, $loc) !== false;
	}


	/**
	 * Suspend the current execution for the given time (in seconds).
	 * 
	 * @param float $seconds
	 * 
	 * @return void
	 */
	static public function sleep ($seconds) {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:58: characters 10-51
		usleep((int)($seconds * 1000000));
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:58: characters 3-51
		return;
	}


	/**
	 * Returns the process standard error on which you can write.
	 * 
	 * @return Output
	 */
	static public function stderr () {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:140: characters 3-87
		$p = (defined("STDERR") ? STDERR : fopen("php://stderr", "w"));
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:141: characters 3-43
		return new FileOutput($p);
	}


	/**
	 * Returns the process standard input, from which you can read what user enters. Usually it will block until the user send a full input line. See `getChar` for an alternative.
	 * 
	 * @return Input
	 */
	static public function stdin () {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:130: characters 3-84
		$p = (defined("STDIN") ? STDIN : fopen("php://stdin", "r"));
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:131: characters 3-42
		return new FileInput($p);
	}


	/**
	 * Returns the process standard output on which you can write.
	 * 
	 * @return Output
	 */
	static public function stdout () {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:135: characters 3-87
		$p = (defined("STDOUT") ? STDOUT : fopen("php://stdout", "w"));
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:136: characters 3-43
		return new FileOutput($p);
	}


	/**
	 * Returns the name of the system you are running on. For instance :
	 * "Windows", "Linux", "BSD" and "Mac" depending on your desktop OS.
	 * 
	 * @return string
	 */
	static public function systemName () {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:77: characters 3-33
		$s = php_uname("s");
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:78: characters 3-26
		$p = HxString::indexOf($s, " ");
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:79: characters 10-39
		if ($p >= 0) {
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:79: characters 20-34
			return HxString::substr($s, 0, $p);
		} else {
			#/usr/local/lib/haxe/std/php/_std/Sys.hx:79: characters 37-38
			return $s;
		}
	}


	/**
	 * Gives the most precise timestamp value (in seconds).
	 * 
	 * @return float
	 */
	static public function time () {
		#/usr/local/lib/haxe/std/php/_std/Sys.hx:104: characters 3-32
		return microtime(true);
	}


	/**
	 * @internal
	 * @access private
	 */
	static public function __hx__init ()
	{
		static $called = false;
		if ($called) return;
		$called = true;


$this1 = [];
self::$customEnvVars = $this1;
self::$_programPath = (realpath($_SERVER["SCRIPT_FILENAME"]) ?: null);
	}
}


Boot::registerClass(Sys::class, 'Sys');
Sys::__hx__init();
