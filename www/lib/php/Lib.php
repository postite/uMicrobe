<?php
/**
 * Generated by Haxe 4.0.0 (git build development @ da28365)
 * Haxe source file: /usr/local/lib/haxe/std/php/Lib.hx
 */

namespace php;

use \haxe\ds\StringMap;
use \php\_Boot\HxException;
use \php\_Boot\HxAnon;

/**
 * Platform-specific PHP Library. Provides some platform-specific functions
 * for the PHP target, such as conversion from Haxe types to native types
 * and vice-versa.
 */
class Lib {
	/**
	 * @var bool
	 */
	static public $loaded = false;


	/**
	 * @param StringMap $hash
	 * 
	 * @return mixed
	 */
	static public function associativeArrayOfHash ($hash) {
		#/usr/local/lib/haxe/std/php/Lib.hx:107: characters 3-35
		return $hash->data;
	}


	/**
	 * @param mixed $ob
	 * 
	 * @return mixed
	 */
	static public function associativeArrayOfObject ($ob) {
		#/usr/local/lib/haxe/std/php/Lib.hx:120: characters 3-26
		return (array)($ob);
	}


	/**
	 * Displays structured information about one or more expressions
	 * that includes its type and value. Arrays and objects are
	 * explored recursively with values indented to show structure.
	 * 
	 * @param mixed $v
	 * 
	 * @return void
	 */
	static public function dump ($v) {
		#/usr/local/lib/haxe/std/php/Lib.hx:56: characters 3-21
		var_dump($v);
	}


	/**
	 * Find out whether an extension is loaded.
	 * 
	 * @param string $name
	 * 
	 * @return bool
	 */
	static public function extensionLoaded ($name) {
		#/usr/local/lib/haxe/std/php/Lib.hx:78: characters 3-39
		return extension_loaded($name);
	}


	/**
	 * Tries to load all compiled php files and returns list of types.
	 * 
	 * @return mixed
	 */
	static public function getClasses () {
		#/usr/local/lib/haxe/std/php/Lib.hx:147: lines 147-151
		if (!Lib::$loaded) {
			#/usr/local/lib/haxe/std/php/Lib.hx:148: characters 4-17
			Lib::$loaded = true;
			#/usr/local/lib/haxe/std/php/Lib.hx:149: characters 4-70
			$reflection = new \ReflectionClass(Boot::getPhpName("php.Boot"));
			#/usr/local/lib/haxe/std/php/Lib.hx:150: characters 4-56
			Lib::loadLib(dirname($reflection->getFileName(), 2));
		}
		#/usr/local/lib/haxe/std/php/Lib.hx:153: characters 3-27
		$result = new HxAnon();
		#/usr/local/lib/haxe/std/php/Lib.hx:154: lines 154-165
		foreach ((Boot::getRegisteredAliases()) as $phpName => $haxeName) {
			#/usr/local/lib/haxe/std/php/Lib.hx:155: characters 4-36
			$parts = \Array_hx::wrap(explode(".", $haxeName));
			#/usr/local/lib/haxe/std/php/Lib.hx:156: characters 4-21
			$obj = $result;
			#/usr/local/lib/haxe/std/php/Lib.hx:157: lines 157-163
			while ($parts->length > 1) {
				#/usr/local/lib/haxe/std/php/Lib.hx:158: characters 16-29
				if ($parts->length > 0) {
					#/usr/local/lib/haxe/std/php/Lib.hx:158: characters 16-29
					$parts->length--;
				}
				#/usr/local/lib/haxe/std/php/Lib.hx:158: characters 5-30
				$pack = array_shift($parts->arr);
				#/usr/local/lib/haxe/std/php/Lib.hx:159: characters 21-24
				$tmp = $obj;
				#/usr/local/lib/haxe/std/php/Lib.hx:159: characters 26-30
				$tmp1 = $pack;
				#/usr/local/lib/haxe/std/php/Lib.hx:159: lines 159-161
				if ($tmp->{$tmp1} === null) {
					#/usr/local/lib/haxe/std/php/Lib.hx:160: characters 22-25
					$tmp2 = $obj;
					#/usr/local/lib/haxe/std/php/Lib.hx:160: characters 27-31
					$tmp3 = $pack;
					#/usr/local/lib/haxe/std/php/Lib.hx:160: characters 6-36
					$tmp2->{$tmp3} = new HxAnon();
				}
				#/usr/local/lib/haxe/std/php/Lib.hx:162: characters 24-27
				$tmp4 = $obj;
				#/usr/local/lib/haxe/std/php/Lib.hx:162: characters 29-33
				$tmp5 = $pack;
				#/usr/local/lib/haxe/std/php/Lib.hx:162: characters 5-34
				$obj = $tmp4->{$tmp5};
			}
			#/usr/local/lib/haxe/std/php/Lib.hx:164: characters 20-23
			$tmp6 = $obj;
			#/usr/local/lib/haxe/std/php/Lib.hx:164: characters 25-33
			$tmp7 = ($parts->arr[0] ?? null);
			#/usr/local/lib/haxe/std/php/Lib.hx:164: characters 4-58
			$tmp6->{$tmp7} = Boot::getClass($phpName);
		};
		#/usr/local/lib/haxe/std/php/Lib.hx:167: characters 3-16
		return $result;
	}


	/**
	 * @param mixed $arr
	 * 
	 * @return StringMap
	 */
	static public function hashOfAssociativeArray ($arr) {
		#/usr/local/lib/haxe/std/php/Lib.hx:101: characters 3-32
		$result = new StringMap();
		#/usr/local/lib/haxe/std/php/Lib.hx:102: characters 19-36
		$result->data = $arr;
		#/usr/local/lib/haxe/std/php/Lib.hx:103: characters 3-16
		return $result;
	}


	/**
	 * @return bool
	 */
	static public function isCli () {
		#/usr/local/lib/haxe/std/php/Lib.hx:82: characters 3-59
		return 0 === strncasecmp(PHP_SAPI, "cli", 3);
	}


	/**
	 * Loads types defined in the specified directory.
	 * 
	 * @param string $pathToLib
	 * 
	 * @return void
	 */
	static public function loadLib ($pathToLib) {
		#/usr/local/lib/haxe/std/php/Lib.hx:175: characters 3-49
		$absolutePath = realpath($pathToLib);
		#/usr/local/lib/haxe/std/php/Lib.hx:176: characters 3-34
		if ($absolutePath === false) {
			#/usr/local/lib/haxe/std/php/Lib.hx:176: characters 29-34
			throw new HxException("Failed to read path: " . ($pathToLib??'null'));
		}
		#/usr/local/lib/haxe/std/php/Lib.hx:177: lines 177-181
		foreach ((glob("" . ($absolutePath??'null') . "/*.php")) as $_ => $fileName) {
			#/usr/local/lib/haxe/std/php/Lib.hx:178: lines 178-180
			if (!is_dir($fileName)) {
				#/usr/local/lib/haxe/std/php/Lib.hx:179: characters 5-34
				require_once($fileName);
			}
		};
		#/usr/local/lib/haxe/std/php/Lib.hx:182: lines 182-184
		foreach ((glob("" . ($absolutePath??'null') . "/*", GLOB_ONLYDIR)) as $_1 => $dirName) {
			#/usr/local/lib/haxe/std/php/Lib.hx:183: characters 4-20
			Lib::loadLib($dirName);
		};
	}


	/**
	 * See the documentation for the equivalent PHP function for details on usage:
	 * <http://php.net/manual/en/function.mail.php>
	 * @param	to
	 * @param	subject
	 * @param	message
	 * @param	?additionalHeaders
	 * @param	?additionalParameters
	 * 
	 * @param string $to
	 * @param string $subject
	 * @param string $message
	 * @param string $additionalHeaders
	 * @param string $additionalParameters
	 * 
	 * @return bool
	 */
	static public function mail ($to, $subject, $message, $additionalHeaders = null, $additionalParameters = null) {
		#/usr/local/lib/haxe/std/php/Lib.hx:133: characters 3-84
		return mail($to, $subject, $message, $additionalHeaders, $additionalParameters);
	}


	/**
	 * @param mixed $arr
	 * 
	 * @return mixed
	 */
	static public function objectOfAssociativeArray ($arr) {
		#/usr/local/lib/haxe/std/php/Lib.hx:111: lines 111-115
		foreach ($arr as $key => $value) {
			#/usr/local/lib/haxe/std/php/Lib.hx:112: lines 112-114
			if (is_array($value)) {
				#/usr/local/lib/haxe/std/php/Lib.hx:113: characters 16-47
				$tmp = Lib::objectOfAssociativeArray($value);
				#/usr/local/lib/haxe/std/php/Lib.hx:113: characters 5-47
				$arr[$key] = $tmp;
			}
		};
		#/usr/local/lib/haxe/std/php/Lib.hx:116: characters 3-30
		return new HxAnon($arr);
	}


	/**
	 * Print the specified value on the default output.
	 * 
	 * @param mixed $v
	 * 
	 * @return void
	 */
	static public function print ($v) {
		#/usr/local/lib/haxe/std/php/Lib.hx:38: characters 3-29
		echo(\Std::string($v));
	}


	/**
	 * Output file content from the given file name.
	 * 
	 * @param string $file
	 * 
	 * @return int
	 */
	static public function printFile ($file) {
		#/usr/local/lib/haxe/std/php/Lib.hx:89: characters 3-52
		return fpassthru(fopen($file, "r"));
	}


	/**
	 * Print the specified value on the default output followed by
	 * a newline character.
	 * 
	 * @param mixed $v
	 * 
	 * @return void
	 */
	static public function println ($v) {
		#/usr/local/lib/haxe/std/php/Lib.hx:46: characters 3-11
		echo(\Std::string($v));
		#/usr/local/lib/haxe/std/php/Lib.hx:47: characters 3-14
		echo("\x0A");
	}


	/**
	 * For neko compatibility only.
	 * 
	 * @param mixed $e
	 * 
	 * @return void
	 */
	static public function rethrow ($e) {
		#/usr/local/lib/haxe/std/php/Lib.hx:140: characters 3-8
		throw (is_object($__hx__throw = $e) && $__hx__throw instanceof \Throwable ? $__hx__throw : new HxException($__hx__throw));
	}


	/**
	 * Serialize using native PHP serialization. This will return a binary
	 * `String` that can be stored for long term usage.
	 * 
	 * @param mixed $v
	 * 
	 * @return string
	 */
	static public function serialize ($v) {
		#/usr/local/lib/haxe/std/php/Lib.hx:64: characters 3-29
		return serialize($v);
	}


	/**
	 * @param mixed $a
	 * 
	 * @return \Array_hx
	 */
	static public function toHaxeArray ($a) {
		#/usr/local/lib/haxe/std/php/Lib.hx:97: characters 3-39
		return \Array_hx::wrap($a);
	}


	/**
	 * @param \Array_hx $a
	 * 
	 * @return mixed
	 */
	static public function toPhpArray ($a) {
		#/usr/local/lib/haxe/std/php/Lib.hx:93: characters 3-31
		return $a->arr;
	}


	/**
	 * Unserialize a `String` using native PHP serialization. See `php.Lib.serialize()`.
	 * 
	 * @param string $s
	 * 
	 * @return mixed
	 */
	static public function unserialize ($s) {
		#/usr/local/lib/haxe/std/php/Lib.hx:71: characters 3-31
		return unserialize($s);
	}
}


Boot::registerClass(Lib::class, 'php.Lib');
