<?php

// Generated by Haxe 3.4.7
class hscript_Parser {
	public function __construct() {
		if(!php_Boot::$skip_constructor) {
		$GLOBALS['%s']->push("hscript.Parser::new");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->uid = 0;
		$this->preprocesorValues = new haxe_ds_StringMap();
		$this->line = 1;
		$this->opChars = "+*/-=!><&|^%~";
		$this->identChars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_";
		$priorities = (new _hx_array(array((new _hx_array(array("%"))), (new _hx_array(array("*", "/"))), (new _hx_array(array("+", "-"))), (new _hx_array(array("<<", ">>", ">>>"))), (new _hx_array(array("|", "&", "^"))), (new _hx_array(array("==", "!=", ">", "<", ">=", "<="))), (new _hx_array(array("..."))), (new _hx_array(array("&&"))), (new _hx_array(array("||"))), (new _hx_array(array("=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "&=", "^=", "=>"))))));
		$this->opPriority = new haxe_ds_StringMap();
		$this->opRightAssoc = new haxe_ds_StringMap();
		$this->unops = new haxe_ds_StringMap();
		{
			$_g1 = 0;
			$_g = $priorities->length;
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				{
					$_g2 = 0;
					$_g3 = $priorities[$i];
					while($_g2 < $_g3->length) {
						$x = $_g3[$_g2];
						$_g2 = $_g2 + 1;
						$this->opPriority->set($x, $i);
						if($i === 9) {
							$this->opRightAssoc->set($x, true);
						}
						unset($x);
					}
					unset($_g3,$_g2);
				}
				unset($i);
			}
		}
		{
			$_g4 = 0;
			$_g11 = (new _hx_array(array("!", "++", "--", "-", "~")));
			while($_g4 < $_g11->length) {
				$x1 = $_g11[$_g4];
				$_g4 = $_g4 + 1;
				{
					$tmp = null;
					if($x1 !== "++") {
						$tmp = $x1 === "--";
					} else {
						$tmp = true;
					}
					$this->unops->set($x1, $tmp);
					unset($tmp);
				}
				unset($x1);
			}
		}
		$GLOBALS['%s']->pop();
	}}
	public $line;
	public $opChars;
	public $identChars;
	public $opPriority;
	public $opRightAssoc;
	public $unops;
	public $preprocesorValues;
	public $allowJSON;
	public $allowTypes;
	public $allowMetadata;
	public $input;
	public $char;
	public $ops;
	public $idents;
	public $uid;
	public $tokens;
	public function error($err, $pmin, $pmax) {
		$GLOBALS['%s']->push("hscript.Parser::error");
		$__hx__spos = $GLOBALS['%s']->length;
		throw new HException($err);
		$GLOBALS['%s']->pop();
	}
	public function invalidChar($c) {
		$GLOBALS['%s']->push("hscript.Parser::invalidChar");
		$__hx__spos = $GLOBALS['%s']->length;
		throw new HException(hscript_Error::EInvalidChar($c));
		$GLOBALS['%s']->pop();
	}
	public function initParser($origin) {
		$GLOBALS['%s']->push("hscript.Parser::initParser");
		$__hx__spos = $GLOBALS['%s']->length;
		$this->preprocStack = (new _hx_array(array()));
		$this->tokens = new haxe_ds_GenericStack();
		$this->char = -1;
		$this->ops = new _hx_array(array());
		$this->idents = new _hx_array(array());
		$this->uid = 0;
		{
			$_g1 = 0;
			$_g = strlen($this->opChars);
			while($_g1 < $_g) {
				$_g1 = $_g1 + 1;
				$i = $_g1 - 1;
				$this->ops[_hx_char_code_at($this->opChars, $i)] = true;
				unset($i);
			}
		}
		{
			$_g11 = 0;
			$_g2 = strlen($this->identChars);
			while($_g11 < $_g2) {
				$_g11 = $_g11 + 1;
				$i1 = $_g11 - 1;
				$this->idents[_hx_char_code_at($this->identChars, $i1)] = true;
				unset($i1);
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function parseString($s, $origin = null) {
		$GLOBALS['%s']->push("hscript.Parser::parseString");
		$__hx__spos = $GLOBALS['%s']->length;
		if($origin === null) {
			$origin = "hscript";
		}
		{
			$tmp = $this->parse(new haxe_io_StringInput($s), $origin);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function parse($s, $origin = null) {
		$GLOBALS['%s']->push("hscript.Parser::parse");
		$__hx__spos = $GLOBALS['%s']->length;
		if($origin === null) {
			$origin = "hscript";
		}
		$this->initParser($origin);
		$this->input = $s;
		$a = new _hx_array(array());
		while(true) {
			$tk = $this->token();
			if($tk === hscript_Token::$TEof) {
				break;
			}
			{
				$_this = $this->tokens;
				$_this->head = new haxe_ds_GenericCell($tk, $_this->head);
				unset($_this);
			}
			$this->parseFullExpr($a);
			unset($tk);
		}
		if($a->length === 1) {
			$tmp = $a[0];
			$GLOBALS['%s']->pop();
			return $tmp;
		} else {
			$tmp = hscript_Expr::EBlock($a);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function unexpected($tk) {
		$GLOBALS['%s']->push("hscript.Parser::unexpected");
		$__hx__spos = $GLOBALS['%s']->length;
		throw new HException(hscript_Error::EUnexpected($this->tokenString($tk)));
		$GLOBALS['%s']->pop();
	}
	public function push($tk) {
		$GLOBALS['%s']->push("hscript.Parser::push");
		$__hx__spos = $GLOBALS['%s']->length;
		$_this = $this->tokens;
		$_this->head = new haxe_ds_GenericCell($tk, $_this->head);
		$GLOBALS['%s']->pop();
	}
	public function ensure($tk) {
		$GLOBALS['%s']->push("hscript.Parser::ensure");
		$__hx__spos = $GLOBALS['%s']->length;
		$t = $this->token();
		if($t !== $tk) {
			$this->unexpected($t);
		}
		$GLOBALS['%s']->pop();
	}
	public function ensureToken($tk) {
		$GLOBALS['%s']->push("hscript.Parser::ensureToken");
		$__hx__spos = $GLOBALS['%s']->length;
		$t = $this->token();
		if(!Type::enumEq($t, $tk)) {
			$this->unexpected($t);
		}
		$GLOBALS['%s']->pop();
	}
	public function maybe($tk) {
		$GLOBALS['%s']->push("hscript.Parser::maybe");
		$__hx__spos = $GLOBALS['%s']->length;
		$t = $this->token();
		if(Type::enumEq($t, $tk)) {
			$GLOBALS['%s']->pop();
			return true;
		}
		{
			$_this = $this->tokens;
			$_this->head = new haxe_ds_GenericCell($t, $_this->head);
		}
		{
			$GLOBALS['%s']->pop();
			return false;
		}
		$GLOBALS['%s']->pop();
	}
	public function getIdent() {
		$GLOBALS['%s']->push("hscript.Parser::getIdent");
		$__hx__spos = $GLOBALS['%s']->length;
		$tk = $this->token();
		if($tk->index === 2) {
			$id = _hx_deref($tk)->params[0];
			{
				$GLOBALS['%s']->pop();
				return $id;
			}
		} else {
			$this->unexpected($tk);
			{
				$GLOBALS['%s']->pop();
				return null;
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function expr($e) {
		$GLOBALS['%s']->push("hscript.Parser::expr");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$GLOBALS['%s']->pop();
			return $e;
		}
		$GLOBALS['%s']->pop();
	}
	public function pmin($e) {
		$GLOBALS['%s']->push("hscript.Parser::pmin");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$GLOBALS['%s']->pop();
			return 0;
		}
		$GLOBALS['%s']->pop();
	}
	public function pmax($e) {
		$GLOBALS['%s']->push("hscript.Parser::pmax");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$GLOBALS['%s']->pop();
			return 0;
		}
		$GLOBALS['%s']->pop();
	}
	public function mk($e, $pmin = null, $pmax = null) {
		$GLOBALS['%s']->push("hscript.Parser::mk");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$GLOBALS['%s']->pop();
			return $e;
		}
		$GLOBALS['%s']->pop();
	}
	public function isBlock($e) {
		$GLOBALS['%s']->push("hscript.Parser::isBlock");
		$__hx__spos = $GLOBALS['%s']->length;
		switch($e->index) {
		case 2:{
			$e1 = _hx_deref($e)->params[2];
			$t = _hx_deref($e)->params[1];
			if($e1 !== null) {
				$tmp = $this->isBlock($e1);
				$GLOBALS['%s']->pop();
				return $tmp;
			} else {
				if($t !== null) {
					if($t === null) {
						$GLOBALS['%s']->pop();
						return false;
					} else {
						if($t->index === 2) {
							$GLOBALS['%s']->pop();
							return true;
						} else {
							$GLOBALS['%s']->pop();
							return false;
						}
					}
				} else {
					$GLOBALS['%s']->pop();
					return false;
				}
			}
		}break;
		case 6:{
			$e2 = _hx_deref($e)->params[2];
			{
				$tmp = $this->isBlock($e2);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 7:{
			$e3 = _hx_deref($e)->params[2];
			$prefix = _hx_deref($e)->params[1];
			if(!$prefix) {
				$tmp = $this->isBlock($e3);
				$GLOBALS['%s']->pop();
				return $tmp;
			} else {
				$GLOBALS['%s']->pop();
				return false;
			}
		}break;
		case 9:{
			$e21 = _hx_deref($e)->params[2];
			$e11 = _hx_deref($e)->params[1];
			if($e21 !== null) {
				$tmp = $this->isBlock($e21);
				$GLOBALS['%s']->pop();
				return $tmp;
			} else {
				$tmp = $this->isBlock($e11);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 10:{
			$e4 = _hx_deref($e)->params[1];
			{
				$tmp = $this->isBlock($e4);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 11:{
			$e5 = _hx_deref($e)->params[2];
			{
				$tmp = $this->isBlock($e5);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 14:{
			$e6 = _hx_deref($e)->params[1];
			{
				$tmp = $this->isBlock($e6);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 15:{
			$e7 = _hx_deref($e)->params[0];
			if($e7 !== null) {
				$tmp = $this->isBlock($e7);
				$GLOBALS['%s']->pop();
				return $tmp;
			} else {
				$GLOBALS['%s']->pop();
				return false;
			}
		}break;
		case 20:{
			$e8 = _hx_deref($e)->params[3];
			{
				$tmp = $this->isBlock($e8);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 4:case 21:case 23:{
			$GLOBALS['%s']->pop();
			return true;
		}break;
		case 24:{
			$e9 = _hx_deref($e)->params[1];
			{
				$tmp = $this->isBlock($e9);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 25:{
			$e10 = _hx_deref($e)->params[2];
			{
				$tmp = $this->isBlock($e10);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		default:{
			$GLOBALS['%s']->pop();
			return false;
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseFullExpr($exprs) {
		$GLOBALS['%s']->push("hscript.Parser::parseFullExpr");
		$__hx__spos = $GLOBALS['%s']->length;
		$e = $this->parseExpr();
		$exprs->push($e);
		$tk = $this->token();
		while(true) {
			$tmp = null;
			if($tk === hscript_Token::$TComma) {
				if($e->index === 2) {
					$tmp = true;
				} else {
					$tmp = false;
				}
			} else {
				$tmp = false;
			}
			if(!$tmp) {
				break;
			}
			$e = $this->parseStructure("var");
			$exprs->push($e);
			$tk = $this->token();
			unset($tmp);
		}
		$tmp1 = null;
		if($tk !== hscript_Token::$TSemicolon) {
			$tmp1 = $tk !== hscript_Token::$TEof;
		} else {
			$tmp1 = false;
		}
		if($tmp1) {
			if($this->isBlock($e)) {
				$_this = $this->tokens;
				$_this->head = new haxe_ds_GenericCell($tk, $_this->head);
			} else {
				$this->unexpected($tk);
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function parseObject($p1) {
		$GLOBALS['%s']->push("hscript.Parser::parseObject");
		$__hx__spos = $GLOBALS['%s']->length;
		$fl = new _hx_array(array());
		while(true) {
			$tk = $this->token();
			$id = null;
			switch($tk->index) {
			case 1:{
				$c = _hx_deref($tk)->params[0];
				{
					if(!$this->allowJSON) {
						$this->unexpected($tk);
					}
					if($c->index === 2) {
						$s = _hx_deref($c)->params[0];
						$id = $s;
					} else {
						$this->unexpected($tk);
					}
				}
			}break;
			case 2:{
				$i = _hx_deref($tk)->params[0];
				$id = $i;
			}break;
			case 7:{
				break 2;
			}break;
			default:{
				$this->unexpected($tk);
			}break;
			}
			{
				$t = $this->token();
				if($t !== hscript_Token::$TDoubleDot) {
					$this->unexpected($t);
				}
				unset($t);
			}
			$fl->push(_hx_anonymous(array("name" => $id, "e" => $this->parseExpr())));
			$tk = $this->token();
			switch($tk->index) {
			case 7:{
				break 2;
			}break;
			case 9:{
			}break;
			default:{
				$this->unexpected($tk);
			}break;
			}
			unset($tk,$id);
		}
		{
			$tmp = $this->parseExprNext(hscript_Expr::EObject($fl));
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseExpr() {
		$GLOBALS['%s']->push("hscript.Parser::parseExpr");
		$__hx__spos = $GLOBALS['%s']->length;
		$tk = $this->token();
		switch($tk->index) {
		case 1:{
			$c = _hx_deref($tk)->params[0];
			{
				$tmp = $this->parseExprNext(hscript_Expr::EConst($c));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 2:{
			$id = _hx_deref($tk)->params[0];
			$e = $this->parseStructure($id);
			if($e === null) {
				$e = hscript_Expr::EIdent($id);
			}
			{
				$tmp = $this->parseExprNext($e);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 3:{
			$op = _hx_deref($tk)->params[0];
			if($this->unops->exists($op)) {
				$start = 0;
				$e1 = $this->parseExpr();
				if($op === "-") {
					if($e1->index === 0) {
						switch(_hx_deref($e1)->params[0]->index) {
						case 0:{
							$i = _hx_deref(_hx_deref($e1)->params[0])->params[0];
							{
								$tmp = hscript_Expr::EConst(hscript_Const::CInt(-$i));
								$GLOBALS['%s']->pop();
								return $tmp;
							}
						}break;
						case 1:{
							$f = _hx_deref(_hx_deref($e1)->params[0])->params[0];
							{
								$tmp = hscript_Expr::EConst(hscript_Const::CFloat(-$f));
								$GLOBALS['%s']->pop();
								return $tmp;
							}
						}break;
						default:{
						}break;
						}
					}
				}
				{
					$tmp = $this->makeUnop($op, $e1);
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			}
			{
				$tmp = $this->unexpected($tk);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 4:{
			$e2 = $this->parseExpr();
			{
				$t = $this->token();
				if($t !== hscript_Token::$TPClose) {
					$this->unexpected($t);
				}
			}
			{
				$tmp = $this->parseExprNext(hscript_Expr::EParent($e2));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 6:{
			$tk = $this->token();
			switch($tk->index) {
			case 1:{
				$c1 = _hx_deref($tk)->params[0];
				if($this->allowJSON) {
					if($c1->index === 2) {
						$tk2 = $this->token();
						{
							$_this = $this->tokens;
							$_this->head = new haxe_ds_GenericCell($tk2, $_this->head);
						}
						{
							$_this1 = $this->tokens;
							$_this1->head = new haxe_ds_GenericCell($tk, $_this1->head);
						}
						if($tk2->index === 14) {
							$tmp = $this->parseExprNext($this->parseObject(0));
							$GLOBALS['%s']->pop();
							return $tmp;
						}
					} else {
						$_this2 = $this->tokens;
						$_this2->head = new haxe_ds_GenericCell($tk, $_this2->head);
					}
				} else {
					$_this3 = $this->tokens;
					$_this3->head = new haxe_ds_GenericCell($tk, $_this3->head);
				}
			}break;
			case 2:{
				$tk21 = $this->token();
				{
					$_this4 = $this->tokens;
					$_this4->head = new haxe_ds_GenericCell($tk21, $_this4->head);
				}
				{
					$_this5 = $this->tokens;
					$_this5->head = new haxe_ds_GenericCell($tk, $_this5->head);
				}
				if($tk21->index === 14) {
					$tmp = $this->parseExprNext($this->parseObject(0));
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			}break;
			case 7:{
				$tmp = $this->parseExprNext(hscript_Expr::EObject((new _hx_array(array()))));
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			default:{
				$_this6 = $this->tokens;
				$_this6->head = new haxe_ds_GenericCell($tk, $_this6->head);
			}break;
			}
			$a = new _hx_array(array());
			while(true) {
				$this->parseFullExpr($a);
				$tk = $this->token();
				if($tk === hscript_Token::$TBrClose) {
					break;
				}
				{
					$_this7 = $this->tokens;
					$_this7->head = new haxe_ds_GenericCell($tk, $_this7->head);
					unset($_this7);
				}
			}
			{
				$tmp = hscript_Expr::EBlock($a);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 11:{
			$a1 = new _hx_array(array());
			$tk = $this->token();
			while($tk !== hscript_Token::$TBkClose) {
				{
					$_this8 = $this->tokens;
					$_this8->head = new haxe_ds_GenericCell($tk, $_this8->head);
					unset($_this8);
				}
				$a1->push($this->parseExpr());
				$tk = $this->token();
				if($tk === hscript_Token::$TComma) {
					$tk = $this->token();
				}
			}
			if($a1->length === 1) {
				$_g = $a1[0];
				switch($_g->index) {
				case 10:case 11:case 24:{
					$tmp = "__a_" . _hx_string_rec($this->uid++, "");
					$e3 = hscript_Expr::EBlock((new _hx_array(array(hscript_Expr::EVar($tmp, null, hscript_Expr::EArrayDecl((new _hx_array(array())))), $this->mapCompr($tmp, $a1[0]), hscript_Expr::EIdent($tmp)))));
					{
						$tmp2 = $this->parseExprNext($e3);
						$GLOBALS['%s']->pop();
						return $tmp2;
					}
				}break;
				default:{
				}break;
				}
			}
			{
				$tmp = $this->parseExprNext(hscript_Expr::EArrayDecl($a1));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 15:{
			$id1 = _hx_deref($tk)->params[0];
			if($this->allowMetadata) {
				$args = $this->parseMetaArgs();
				{
					$tmp = hscript_Expr::EMeta($id1, $args, $this->parseExpr());
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			} else {
				$tmp = $this->unexpected($tk);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		default:{
			$tmp = $this->unexpected($tk);
			$GLOBALS['%s']->pop();
			return $tmp;
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseMetaArgs() {
		$GLOBALS['%s']->push("hscript.Parser::parseMetaArgs");
		$__hx__spos = $GLOBALS['%s']->length;
		$tk = $this->token();
		if($tk !== hscript_Token::$TPOpen) {
			{
				$_this = $this->tokens;
				$_this->head = new haxe_ds_GenericCell($tk, $_this->head);
			}
			{
				$GLOBALS['%s']->pop();
				return null;
			}
		}
		$args = (new _hx_array(array()));
		$tk = $this->token();
		if($tk !== hscript_Token::$TPClose) {
			{
				$_this1 = $this->tokens;
				$_this1->head = new haxe_ds_GenericCell($tk, $_this1->head);
			}
			while(true) {
				$args->push($this->parseExpr());
				{
					$_g = $this->token();
					switch($_g->index) {
					case 5:{
						break 2;
					}break;
					case 9:{
					}break;
					default:{
						$tk1 = $_g;
						$this->unexpected($tk1);
					}break;
					}
					unset($_g);
				}
			}
		}
		{
			$GLOBALS['%s']->pop();
			return $args;
		}
		$GLOBALS['%s']->pop();
	}
	public function mapCompr($tmp, $e) {
		$GLOBALS['%s']->push("hscript.Parser::mapCompr");
		$__hx__spos = $GLOBALS['%s']->length;
		$edef = null;
		switch($e->index) {
		case 3:{
			$e2 = _hx_deref($e)->params[0];
			$edef = hscript_Expr::EParent($this->mapCompr($tmp, $e2));
		}break;
		case 4:{
			if(_hx_deref($e)->params[0]->length === 1) {
				$e1 = _hx_deref($e)->params[0][0];
				$edef = hscript_Expr::EBlock((new _hx_array(array($this->mapCompr($tmp, $e1)))));
			} else {
				$edef = hscript_Expr::ECall(hscript_Expr::EField(hscript_Expr::EIdent($tmp), "push"), (new _hx_array(array($e))));
			}
		}break;
		case 9:{
			$e21 = _hx_deref($e)->params[2];
			$e11 = _hx_deref($e)->params[1];
			$cond = _hx_deref($e)->params[0];
			if($e21 === null) {
				$edef = hscript_Expr::EIf($cond, $this->mapCompr($tmp, $e11), null);
			} else {
				$edef = hscript_Expr::ECall(hscript_Expr::EField(hscript_Expr::EIdent($tmp), "push"), (new _hx_array(array($e))));
			}
		}break;
		case 10:{
			$e22 = _hx_deref($e)->params[1];
			$cond1 = _hx_deref($e)->params[0];
			$edef = hscript_Expr::EWhile($cond1, $this->mapCompr($tmp, $e22));
		}break;
		case 11:{
			$e23 = _hx_deref($e)->params[2];
			$it = _hx_deref($e)->params[1];
			$v = _hx_deref($e)->params[0];
			$edef = hscript_Expr::EFor($v, $it, $this->mapCompr($tmp, $e23));
		}break;
		case 24:{
			$e24 = _hx_deref($e)->params[1];
			$cond2 = _hx_deref($e)->params[0];
			$edef = hscript_Expr::EDoWhile($cond2, $this->mapCompr($tmp, $e24));
		}break;
		default:{
			$edef = hscript_Expr::ECall(hscript_Expr::EField(hscript_Expr::EIdent($tmp), "push"), (new _hx_array(array($e))));
		}break;
		}
		{
			$GLOBALS['%s']->pop();
			return $edef;
		}
		$GLOBALS['%s']->pop();
	}
	public function makeUnop($op, $e) {
		$GLOBALS['%s']->push("hscript.Parser::makeUnop");
		$__hx__spos = $GLOBALS['%s']->length;
		switch($e->index) {
		case 6:{
			$e2 = _hx_deref($e)->params[2];
			$e1 = _hx_deref($e)->params[1];
			$bop = _hx_deref($e)->params[0];
			{
				$tmp = hscript_Expr::EBinop($bop, $this->makeUnop($op, $e1), $e2);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 22:{
			$e3 = _hx_deref($e)->params[2];
			$e21 = _hx_deref($e)->params[1];
			$e11 = _hx_deref($e)->params[0];
			{
				$tmp = hscript_Expr::ETernary($this->makeUnop($op, $e11), $e21, $e3);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		default:{
			$tmp = hscript_Expr::EUnop($op, true, $e);
			$GLOBALS['%s']->pop();
			return $tmp;
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function makeBinop($op, $e1, $e) {
		$GLOBALS['%s']->push("hscript.Parser::makeBinop");
		$__hx__spos = $GLOBALS['%s']->length;
		switch($e->index) {
		case 6:{
			$e3 = _hx_deref($e)->params[2];
			$e2 = _hx_deref($e)->params[1];
			$op2 = _hx_deref($e)->params[0];
			$tmp = null;
			$tmp1 = $this->opPriority->get($op);
			if($tmp1 <= $this->opPriority->get($op2)) {
				$tmp = !$this->opRightAssoc->exists($op);
			} else {
				$tmp = false;
			}
			if($tmp) {
				$tmp2 = hscript_Expr::EBinop($op2, $this->makeBinop($op, $e1, $e2), $e3);
				$GLOBALS['%s']->pop();
				return $tmp2;
			} else {
				$tmp2 = hscript_Expr::EBinop($op, $e1, $e);
				$GLOBALS['%s']->pop();
				return $tmp2;
			}
		}break;
		case 22:{
			$e4 = _hx_deref($e)->params[2];
			$e31 = _hx_deref($e)->params[1];
			$e21 = _hx_deref($e)->params[0];
			if($this->opRightAssoc->exists($op)) {
				$tmp = hscript_Expr::EBinop($op, $e1, $e);
				$GLOBALS['%s']->pop();
				return $tmp;
			} else {
				$tmp = hscript_Expr::ETernary($this->makeBinop($op, $e1, $e21), $e31, $e4);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		default:{
			$tmp = hscript_Expr::EBinop($op, $e1, $e);
			$GLOBALS['%s']->pop();
			return $tmp;
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseStructure($id) {
		$GLOBALS['%s']->push("hscript.Parser::parseStructure");
		$__hx__spos = $GLOBALS['%s']->length;
		switch($id) {
		case "break":{
			$tmp = hscript_Expr::$EBreak;
			$GLOBALS['%s']->pop();
			return $tmp;
		}break;
		case "continue":{
			$tmp = hscript_Expr::$EContinue;
			$GLOBALS['%s']->pop();
			return $tmp;
		}break;
		case "do":{
			$e = $this->parseExpr();
			$tk = $this->token();
			if($tk->index === 2) {
				if(_hx_deref($tk)->params[0] !== "while") {
					$this->unexpected($tk);
				}
			} else {
				$this->unexpected($tk);
			}
			$econd = $this->parseExpr();
			{
				$tmp = hscript_Expr::EDoWhile($econd, $e);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "else":{
			$tmp = $this->unexpected(hscript_Token::TId($id));
			$GLOBALS['%s']->pop();
			return $tmp;
		}break;
		case "for":{
			{
				$t = $this->token();
				if($t !== hscript_Token::$TPOpen) {
					$this->unexpected($t);
				}
			}
			$vname = $this->getIdent();
			{
				$t1 = $this->token();
				if(!Type::enumEq($t1, hscript_Token::TId("in"))) {
					$this->unexpected($t1);
				}
			}
			$eiter = $this->parseExpr();
			{
				$t2 = $this->token();
				if($t2 !== hscript_Token::$TPClose) {
					$this->unexpected($t2);
				}
			}
			$e1 = $this->parseExpr();
			{
				$tmp = hscript_Expr::EFor($vname, $eiter, $e1);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "function":{
			$tk1 = $this->token();
			$name = null;
			if($tk1->index === 2) {
				$id1 = _hx_deref($tk1)->params[0];
				$name = $id1;
			} else {
				$_this = $this->tokens;
				$_this->head = new haxe_ds_GenericCell($tk1, $_this->head);
			}
			$inf = $this->parseFunctionDecl();
			$e2 = $inf->body;
			$pmax = 0;
			{
				$tmp = hscript_Expr::EFunction($inf->args, $inf->body, $name, $inf->ret);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "if":{
			{
				$t3 = $this->token();
				if($t3 !== hscript_Token::$TPOpen) {
					$this->unexpected($t3);
				}
			}
			$cond = $this->parseExpr();
			{
				$t4 = $this->token();
				if($t4 !== hscript_Token::$TPClose) {
					$this->unexpected($t4);
				}
			}
			$e11 = $this->parseExpr();
			$e21 = null;
			$semic = false;
			$tk2 = $this->token();
			if($tk2 === hscript_Token::$TSemicolon) {
				$semic = true;
				$tk2 = $this->token();
			}
			if(Type::enumEq($tk2, hscript_Token::TId("else"))) {
				$e21 = $this->parseExpr();
			} else {
				{
					$_this1 = $this->tokens;
					$_this1->head = new haxe_ds_GenericCell($tk2, $_this1->head);
				}
				if($semic) {
					$_this2 = $this->tokens;
					$_this2->head = new haxe_ds_GenericCell(hscript_Token::$TSemicolon, $_this2->head);
				}
			}
			{
				$tmp = hscript_Expr::EIf($cond, $e11, $e21);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "inline":{
			if(!$this->maybe(hscript_Token::TId("function"))) {
				$this->unexpected(hscript_Token::TId("inline"));
			}
			{
				$tmp = $this->parseStructure("function");
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "new":{
			$a = new _hx_array(array());
			$a->push($this->getIdent());
			$next = true;
			while($next) {
				$tk3 = $this->token();
				switch($tk3->index) {
				case 4:{
					$next = false;
				}break;
				case 8:{
					$a->push($this->getIdent());
				}break;
				default:{
					$this->unexpected($tk3);
				}break;
				}
				unset($tk3);
			}
			$args = $this->parseExprList(hscript_Token::$TPClose);
			{
				$tmp = hscript_Expr::ENew($a->join("."), $args);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "return":{
			$tk4 = $this->token();
			{
				$_this3 = $this->tokens;
				$_this3->head = new haxe_ds_GenericCell($tk4, $_this3->head);
			}
			$e3 = null;
			if($tk4 === hscript_Token::$TSemicolon) {
				$e3 = null;
			} else {
				$e3 = $this->parseExpr();
			}
			{
				$tmp = hscript_Expr::EReturn($e3);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "switch":{
			$e4 = $this->parseExpr();
			$def = null;
			$cases = (new _hx_array(array()));
			{
				$t5 = $this->token();
				if($t5 !== hscript_Token::$TBrOpen) {
					$this->unexpected($t5);
				}
			}
			while(true) {
				$tk5 = $this->token();
				switch($tk5->index) {
				case 2:{
					switch(_hx_deref($tk5)->params[0]) {
					case "case":{
						$c = _hx_anonymous(array("values" => (new _hx_array(array())), "expr" => null));
						$cases->push($c);
						while(true) {
							$e5 = $this->parseExpr();
							$c->values->push($e5);
							$tk5 = $this->token();
							switch($tk5->index) {
							case 9:{
							}break;
							case 14:{
								break 2;
							}break;
							default:{
								$this->unexpected($tk5);
							}break;
							}
							unset($e5);
						}
						$exprs = (new _hx_array(array()));
						while(true) {
							$tk5 = $this->token();
							{
								$_this4 = $this->tokens;
								$_this4->head = new haxe_ds_GenericCell($tk5, $_this4->head);
								unset($_this4);
							}
							switch($tk5->index) {
							case 2:{
								switch(_hx_deref($tk5)->params[0]) {
								case "case":case "default":{
									break 3;
								}break;
								default:{
									$this->parseFullExpr($exprs);
								}break;
								}
							}break;
							case 7:{
								break 2;
							}break;
							default:{
								$this->parseFullExpr($exprs);
							}break;
							}
						}
						$tmp = null;
						if($exprs->length === 1) {
							$tmp = $exprs[0];
						} else {
							if($exprs->length === 0) {
								$tmp = hscript_Expr::EBlock((new _hx_array(array())));
							} else {
								$e6 = $exprs[$exprs->length - 1];
								$pmax1 = 0;
								$tmp = hscript_Expr::EBlock($exprs);
							}
						}
						$c->expr = $tmp;
					}break;
					case "default":{
						if($def !== null) {
							$this->unexpected($tk5);
						}
						{
							$t6 = $this->token();
							if($t6 !== hscript_Token::$TDoubleDot) {
								$this->unexpected($t6);
							}
						}
						$exprs1 = (new _hx_array(array()));
						while(true) {
							$tk5 = $this->token();
							{
								$_this5 = $this->tokens;
								$_this5->head = new haxe_ds_GenericCell($tk5, $_this5->head);
								unset($_this5);
							}
							switch($tk5->index) {
							case 2:{
								switch(_hx_deref($tk5)->params[0]) {
								case "case":case "default":{
									break 3;
								}break;
								default:{
									$this->parseFullExpr($exprs1);
								}break;
								}
							}break;
							case 7:{
								break 2;
							}break;
							default:{
								$this->parseFullExpr($exprs1);
							}break;
							}
						}
						if($exprs1->length === 1) {
							$def = $exprs1[0];
						} else {
							if($exprs1->length === 0) {
								$def = hscript_Expr::EBlock((new _hx_array(array())));
							} else {
								$e7 = $exprs1[$exprs1->length - 1];
								$pmax2 = 0;
								$def = hscript_Expr::EBlock($exprs1);
							}
						}
					}break;
					default:{
						$this->unexpected($tk5);
					}break;
					}
				}break;
				case 7:{
					break 2;
				}break;
				default:{
					$this->unexpected($tk5);
				}break;
				}
				unset($tk5);
			}
			{
				$tmp = hscript_Expr::ESwitch($e4, $cases, $def);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "throw":{
			$e8 = $this->parseExpr();
			{
				$tmp = hscript_Expr::EThrow($e8);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "try":{
			$e9 = $this->parseExpr();
			{
				$t7 = $this->token();
				if(!Type::enumEq($t7, hscript_Token::TId("catch"))) {
					$this->unexpected($t7);
				}
			}
			{
				$t8 = $this->token();
				if($t8 !== hscript_Token::$TPOpen) {
					$this->unexpected($t8);
				}
			}
			$vname1 = $this->getIdent();
			{
				$t9 = $this->token();
				if($t9 !== hscript_Token::$TDoubleDot) {
					$this->unexpected($t9);
				}
			}
			$t10 = null;
			if($this->allowTypes) {
				$t10 = $this->parseType();
			} else {
				$t11 = $this->token();
				if(!Type::enumEq($t11, hscript_Token::TId("Dynamic"))) {
					$this->unexpected($t11);
				}
			}
			{
				$t12 = $this->token();
				if($t12 !== hscript_Token::$TPClose) {
					$this->unexpected($t12);
				}
			}
			$ec = $this->parseExpr();
			{
				$tmp = hscript_Expr::ETry($e9, $vname1, $t10, $ec);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "var":{
			$ident = $this->getIdent();
			$tk6 = $this->token();
			$t13 = null;
			$tmp1 = null;
			if($tk6 === hscript_Token::$TDoubleDot) {
				$tmp1 = $this->allowTypes;
			} else {
				$tmp1 = false;
			}
			if($tmp1) {
				$t13 = $this->parseType();
				$tk6 = $this->token();
			}
			$e10 = null;
			if(Type::enumEq($tk6, hscript_Token::TOp("="))) {
				$e10 = $this->parseExpr();
			} else {
				$_this6 = $this->tokens;
				$_this6->head = new haxe_ds_GenericCell($tk6, $_this6->head);
			}
			{
				$tmp = hscript_Expr::EVar($ident, $t13, $e10);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "while":{
			$econd1 = $this->parseExpr();
			$e12 = $this->parseExpr();
			{
				$tmp = hscript_Expr::EWhile($econd1, $e12);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		default:{
			$GLOBALS['%s']->pop();
			return null;
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseExprNext($e1) {
		$GLOBALS['%s']->push("hscript.Parser::parseExprNext");
		$__hx__spos = $GLOBALS['%s']->length;
		$tk = $this->token();
		switch($tk->index) {
		case 3:{
			$op = _hx_deref($tk)->params[0];
			if($this->unops->get($op)) {
				$tmp = null;
				if(!$this->isBlock($e1)) {
					if($e1->index === 3) {
						$tmp = true;
					} else {
						$tmp = false;
					}
				} else {
					$tmp = true;
				}
				if($tmp) {
					{
						$_this = $this->tokens;
						$_this->head = new haxe_ds_GenericCell($tk, $_this->head);
					}
					{
						$GLOBALS['%s']->pop();
						return $e1;
					}
				}
				{
					$tmp2 = $this->parseExprNext(hscript_Expr::EUnop($op, false, $e1));
					$GLOBALS['%s']->pop();
					return $tmp2;
				}
			}
			{
				$tmp = $this->makeBinop($op, $e1, $this->parseExpr());
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 4:{
			$tmp = $this->parseExprNext(hscript_Expr::ECall($e1, $this->parseExprList(hscript_Token::$TPClose)));
			$GLOBALS['%s']->pop();
			return $tmp;
		}break;
		case 8:{
			$field = $this->getIdent();
			{
				$tmp = $this->parseExprNext(hscript_Expr::EField($e1, $field));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 11:{
			$e2 = $this->parseExpr();
			{
				$t = $this->token();
				if($t !== hscript_Token::$TBkClose) {
					$this->unexpected($t);
				}
			}
			{
				$tmp = $this->parseExprNext(hscript_Expr::EArray($e1, $e2));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 13:{
			$e21 = $this->parseExpr();
			{
				$t1 = $this->token();
				if($t1 !== hscript_Token::$TDoubleDot) {
					$this->unexpected($t1);
				}
			}
			$e3 = $this->parseExpr();
			{
				$tmp = hscript_Expr::ETernary($e1, $e21, $e3);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		default:{
			{
				$_this1 = $this->tokens;
				$_this1->head = new haxe_ds_GenericCell($tk, $_this1->head);
			}
			{
				$GLOBALS['%s']->pop();
				return $e1;
			}
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseFunctionDecl() {
		$GLOBALS['%s']->push("hscript.Parser::parseFunctionDecl");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$t = $this->token();
			if($t !== hscript_Token::$TPOpen) {
				$this->unexpected($t);
			}
		}
		$args = new _hx_array(array());
		$tk = $this->token();
		if($tk !== hscript_Token::$TPClose) {
			$done = false;
			while(!$done) {
				$name = null;
				$opt = false;
				if($tk->index === 13) {
					$opt = true;
					$tk = $this->token();
				}
				if($tk->index === 2) {
					$id = _hx_deref($tk)->params[0];
					$name = $id;
					unset($id);
				} else {
					$this->unexpected($tk);
				}
				$arg = _hx_anonymous(array("name" => $name));
				$args->push($arg);
				if($opt) {
					$arg->opt = true;
				}
				if($this->allowTypes) {
					if($this->maybe(hscript_Token::$TDoubleDot)) {
						$arg->t = $this->parseType();
					}
					if($this->maybe(hscript_Token::TOp("="))) {
						$arg->value = $this->parseExpr();
					}
				}
				$tk = $this->token();
				switch($tk->index) {
				case 5:{
					$done = true;
				}break;
				case 9:{
					$tk = $this->token();
				}break;
				default:{
					$this->unexpected($tk);
				}break;
				}
				unset($opt,$name,$arg);
			}
		}
		$ret = null;
		if($this->allowTypes) {
			$tk = $this->token();
			if($tk !== hscript_Token::$TDoubleDot) {
				$_this = $this->tokens;
				$_this->head = new haxe_ds_GenericCell($tk, $_this->head);
			} else {
				$ret = $this->parseType();
			}
		}
		{
			$tmp = _hx_anonymous(array("args" => $args, "ret" => $ret, "body" => $this->parseExpr()));
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function parsePath() {
		$GLOBALS['%s']->push("hscript.Parser::parsePath");
		$__hx__spos = $GLOBALS['%s']->length;
		$path = (new _hx_array(array($this->getIdent())));
		while(true) {
			$t = $this->token();
			if($t !== hscript_Token::$TDot) {
				{
					$_this = $this->tokens;
					$_this->head = new haxe_ds_GenericCell($t, $_this->head);
					unset($_this);
				}
				break;
			}
			$path->push($this->getIdent());
			unset($t);
		}
		{
			$GLOBALS['%s']->pop();
			return $path;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseType() {
		$GLOBALS['%s']->push("hscript.Parser::parseType");
		$__hx__spos = $GLOBALS['%s']->length;
		$t = $this->token();
		switch($t->index) {
		case 2:{
			$v = _hx_deref($t)->params[0];
			{
				$_this = $this->tokens;
				$_this->head = new haxe_ds_GenericCell($t, $_this->head);
			}
			$path = $this->parsePath();
			$params = null;
			$t = $this->token();
			if($t->index === 3) {
				$op = _hx_deref($t)->params[0];
				if($op === "<") {
					$params = (new _hx_array(array()));
					while(true) {
						$params->push($this->parseType());
						$t = $this->token();
						switch($t->index) {
						case 3:{
							$op1 = _hx_deref($t)->params[0];
							{
								if($op1 === ">") {
									break 2;
								}
								if(_hx_char_code_at($op1, 0) === 62) {
									{
										$_this1 = $this->tokens;
										$item = hscript_Token::TOp(_hx_substr($op1, 1, null));
										$_this1->head = new haxe_ds_GenericCell($item, $_this1->head);
									}
									break 2;
								}
							}
						}break;
						case 9:{
							continue 2;
						}break;
						default:{
						}break;
						}
						$this->unexpected($t);
					}
				} else {
					$_this2 = $this->tokens;
					$_this2->head = new haxe_ds_GenericCell($t, $_this2->head);
				}
			} else {
				$_this3 = $this->tokens;
				$_this3->head = new haxe_ds_GenericCell($t, $_this3->head);
			}
			{
				$tmp = $this->parseTypeNext(hscript_CType::CTPath($path, $params));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 4:{
			$t1 = $this->parseType();
			{
				$t2 = $this->token();
				if($t2 !== hscript_Token::$TPClose) {
					$this->unexpected($t2);
				}
			}
			{
				$tmp = $this->parseTypeNext(hscript_CType::CTParent($t1));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 6:{
			$fields = (new _hx_array(array()));
			$meta = null;
			while(true) {
				$t = $this->token();
				switch($t->index) {
				case 2:{
					if(_hx_deref($t)->params[0] === "var") {
						$name = $this->getIdent();
						{
							$t3 = $this->token();
							if($t3 !== hscript_Token::$TDoubleDot) {
								$this->unexpected($t3);
							}
						}
						$fields->push(_hx_anonymous(array("name" => $name, "t" => $this->parseType(), "meta" => $meta)));
						$meta = null;
						{
							$t4 = $this->token();
							if($t4 !== hscript_Token::$TSemicolon) {
								$this->unexpected($t4);
							}
						}
					} else {
						$name1 = _hx_deref($t)->params[0];
						{
							{
								$t5 = $this->token();
								if($t5 !== hscript_Token::$TDoubleDot) {
									$this->unexpected($t5);
								}
							}
							$fields->push(_hx_anonymous(array("name" => $name1, "t" => $this->parseType(), "meta" => $meta)));
							$t = $this->token();
							switch($t->index) {
							case 7:{
								break 3;
							}break;
							case 9:{
							}break;
							default:{
								$this->unexpected($t);
							}break;
							}
						}
					}
				}break;
				case 7:{
					break 2;
				}break;
				case 15:{
					$name2 = _hx_deref($t)->params[0];
					{
						if($meta === null) {
							$meta = (new _hx_array(array()));
						}
						$meta->push(_hx_anonymous(array("name" => $name2, "params" => $this->parseMetaArgs())));
					}
				}break;
				default:{
					$this->unexpected($t);
				}break;
				}
			}
			{
				$tmp = $this->parseTypeNext(hscript_CType::CTAnon($fields));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		default:{
			$tmp = $this->unexpected($t);
			$GLOBALS['%s']->pop();
			return $tmp;
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseTypeNext($t) {
		$GLOBALS['%s']->push("hscript.Parser::parseTypeNext");
		$__hx__spos = $GLOBALS['%s']->length;
		$tk = $this->token();
		if($tk->index === 3) {
			$op = _hx_deref($tk)->params[0];
			if($op !== "->") {
				{
					$_this = $this->tokens;
					$_this->head = new haxe_ds_GenericCell($tk, $_this->head);
				}
				{
					$GLOBALS['%s']->pop();
					return $t;
				}
			}
		} else {
			{
				$_this1 = $this->tokens;
				$_this1->head = new haxe_ds_GenericCell($tk, $_this1->head);
			}
			{
				$GLOBALS['%s']->pop();
				return $t;
			}
		}
		$t2 = $this->parseType();
		if($t2->index === 1) {
			$args = _hx_deref($t2)->params[0];
			$args->unshift($t);
			{
				$GLOBALS['%s']->pop();
				return $t2;
			}
		} else {
			$tmp = hscript_CType::CTFun((new _hx_array(array($t))), $t2);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseExprList($etk) {
		$GLOBALS['%s']->push("hscript.Parser::parseExprList");
		$__hx__spos = $GLOBALS['%s']->length;
		$args = new _hx_array(array());
		$tk = $this->token();
		if($tk === $etk) {
			$GLOBALS['%s']->pop();
			return $args;
		}
		{
			$_this = $this->tokens;
			$_this->head = new haxe_ds_GenericCell($tk, $_this->head);
		}
		while(true) {
			$args->push($this->parseExpr());
			$tk = $this->token();
			if($tk->index !== 9) {
				if($tk === $etk) {
					break;
				}
				$this->unexpected($tk);
			}
		}
		{
			$GLOBALS['%s']->pop();
			return $args;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseModule($content, $origin = null) {
		$GLOBALS['%s']->push("hscript.Parser::parseModule");
		$__hx__spos = $GLOBALS['%s']->length;
		if($origin === null) {
			$origin = "hscript";
		}
		$this->initParser($origin);
		$this->input = new haxe_io_StringInput($content);
		$this->allowTypes = true;
		$this->allowMetadata = true;
		$decls = (new _hx_array(array()));
		while(true) {
			$tk = $this->token();
			if($tk === hscript_Token::$TEof) {
				break;
			}
			{
				$_this = $this->tokens;
				$_this->head = new haxe_ds_GenericCell($tk, $_this->head);
				unset($_this);
			}
			$decls->push($this->parseModuleDecl());
			unset($tk);
		}
		{
			$GLOBALS['%s']->pop();
			return $decls;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseMetadata() {
		$GLOBALS['%s']->push("hscript.Parser::parseMetadata");
		$__hx__spos = $GLOBALS['%s']->length;
		$meta = (new _hx_array(array()));
		while(true) {
			$tk = $this->token();
			if($tk->index === 15) {
				$name = _hx_deref($tk)->params[0];
				$meta->push(_hx_anonymous(array("name" => $name, "params" => $this->parseMetaArgs())));
				unset($name);
			} else {
				{
					$_this = $this->tokens;
					$_this->head = new haxe_ds_GenericCell($tk, $_this->head);
					unset($_this);
				}
				break;
			}
			unset($tk);
		}
		{
			$GLOBALS['%s']->pop();
			return $meta;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseParams() {
		$GLOBALS['%s']->push("hscript.Parser::parseParams");
		$__hx__spos = $GLOBALS['%s']->length;
		if($this->maybe(hscript_Token::TOp("<"))) {
			throw new HException(hscript_Error::EInvalidOp("Unsupported class type parameters"));
		}
		{
			$tmp = _hx_anonymous(array());
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseModuleDecl() {
		$GLOBALS['%s']->push("hscript.Parser::parseModuleDecl");
		$__hx__spos = $GLOBALS['%s']->length;
		$meta = $this->parseMetadata();
		$ident = $this->getIdent();
		$isPrivate = false;
		$isExtern = false;
		while(true) {
			switch($ident) {
			case "extern":{
				$isExtern = true;
			}break;
			case "private":{
				$isPrivate = true;
			}break;
			default:{
				break 2;
			}break;
			}
			$ident = $this->getIdent();
		}
		switch($ident) {
		case "class":{
			$name = $this->getIdent();
			$params = $this->parseParams();
			$extend = null;
			$implement = (new _hx_array(array()));
			while(true) {
				$t = $this->token();
				if($t->index === 2) {
					switch(_hx_deref($t)->params[0]) {
					case "extends":{
						$extend = $this->parseType();
					}break;
					case "implements":{
						$implement->push($this->parseType());
					}break;
					default:{
						{
							$_this = $this->tokens;
							$_this->head = new haxe_ds_GenericCell($t, $_this->head);
						}
						break 2;
					}break;
					}
				} else {
					{
						$_this1 = $this->tokens;
						$_this1->head = new haxe_ds_GenericCell($t, $_this1->head);
						unset($_this1);
					}
					break;
				}
				unset($t);
			}
			$fields = (new _hx_array(array()));
			{
				$t1 = $this->token();
				if($t1 !== hscript_Token::$TBrOpen) {
					$this->unexpected($t1);
				}
			}
			while(!$this->maybe(hscript_Token::$TBrClose)) {
				$fields->push($this->parseField());
			}
			{
				$tmp = hscript_ModuleDecl::DClass(_hx_anonymous(array("name" => $name, "meta" => $meta, "params" => $params, "extend" => $extend, "implement" => $implement, "fields" => $fields, "isPrivate" => $isPrivate, "isExtern" => $isExtern)));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "import":{
			$path = (new _hx_array(array($this->getIdent())));
			$star = false;
			while(true) {
				$t2 = $this->token();
				if($t2 !== hscript_Token::$TDot) {
					{
						$_this2 = $this->tokens;
						$_this2->head = new haxe_ds_GenericCell($t2, $_this2->head);
						unset($_this2);
					}
					break;
				}
				$t2 = $this->token();
				switch($t2->index) {
				case 2:{
					$id = _hx_deref($t2)->params[0];
					$path->push($id);
				}break;
				case 3:{
					if(_hx_deref($t2)->params[0] === "*") {
						$star = true;
					} else {
						$this->unexpected($t2);
					}
				}break;
				default:{
					$this->unexpected($t2);
				}break;
				}
				unset($t2);
			}
			{
				$t3 = $this->token();
				if($t3 !== hscript_Token::$TSemicolon) {
					$this->unexpected($t3);
				}
			}
			{
				$tmp = hscript_ModuleDecl::DImport($path, $star);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "package":{
			$path1 = $this->parsePath();
			{
				$t4 = $this->token();
				if($t4 !== hscript_Token::$TSemicolon) {
					$this->unexpected($t4);
				}
			}
			{
				$tmp = hscript_ModuleDecl::DPackage($path1);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "typedef":{
			$name1 = $this->getIdent();
			$params1 = $this->parseParams();
			{
				$t5 = $this->token();
				if(!Type::enumEq($t5, hscript_Token::TOp("="))) {
					$this->unexpected($t5);
				}
			}
			$t6 = $this->parseType();
			{
				$tmp = hscript_ModuleDecl::DTypedef(_hx_anonymous(array("name" => $name1, "meta" => $meta, "params" => $params1, "isPrivate" => $isPrivate, "t" => $t6)));
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		default:{
			$this->unexpected(hscript_Token::TId($ident));
		}break;
		}
		{
			$GLOBALS['%s']->pop();
			return null;
		}
		$GLOBALS['%s']->pop();
	}
	public function parseField() {
		$GLOBALS['%s']->push("hscript.Parser::parseField");
		$__hx__spos = $GLOBALS['%s']->length;
		$meta = $this->parseMetadata();
		$access = (new _hx_array(array()));
		while(true) {
			$id = $this->getIdent();
			switch($id) {
			case "function":{
				$name = $this->getIdent();
				$inf = $this->parseFunctionDecl();
				{
					$tmp = _hx_anonymous(array("name" => $name, "meta" => $meta, "access" => $access, "kind" => hscript_FieldKind::KFunction(_hx_anonymous(array("args" => $inf->args, "expr" => $inf->body, "ret" => $inf->ret)))));
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			}break;
			case "inline":{
				$access->push(hscript_FieldAccess::$AInline);
			}break;
			case "macro":{
				$access->push(hscript_FieldAccess::$AMacro);
			}break;
			case "override":{
				$access->push(hscript_FieldAccess::$AOverride);
			}break;
			case "private":{
				$access->push(hscript_FieldAccess::$APrivate);
			}break;
			case "public":{
				$access->push(hscript_FieldAccess::$APublic);
			}break;
			case "static":{
				$access->push(hscript_FieldAccess::$AStatic);
			}break;
			case "var":{
				$name1 = $this->getIdent();
				$get = null;
				$set = null;
				if($this->maybe(hscript_Token::$TPOpen)) {
					$get = $this->getIdent();
					{
						$t = $this->token();
						if($t !== hscript_Token::$TComma) {
							$this->unexpected($t);
						}
					}
					$set = $this->getIdent();
					{
						$t1 = $this->token();
						if($t1 !== hscript_Token::$TPClose) {
							$this->unexpected($t1);
						}
					}
				}
				$type = null;
				if($this->maybe(hscript_Token::$TDoubleDot)) {
					$type = $this->parseType();
				} else {
					$type = null;
				}
				$expr = null;
				if($this->maybe(hscript_Token::TOp("="))) {
					$expr = $this->parseExpr();
				} else {
					$expr = null;
				}
				if($expr !== null) {
					if($this->isBlock($expr)) {
						$this->maybe(hscript_Token::$TSemicolon);
					} else {
						$t2 = $this->token();
						if($t2 !== hscript_Token::$TSemicolon) {
							$this->unexpected($t2);
						}
					}
				} else {
					$tmp = null;
					if($type !== null) {
						if($type->index === 2) {
							$tmp = true;
						} else {
							$tmp = false;
						}
					} else {
						$tmp = false;
					}
					if($tmp) {
						$this->maybe(hscript_Token::$TSemicolon);
					} else {
						$t3 = $this->token();
						if($t3 !== hscript_Token::$TSemicolon) {
							$this->unexpected($t3);
						}
					}
				}
				{
					$tmp = _hx_anonymous(array("name" => $name1, "meta" => $meta, "access" => $access, "kind" => hscript_FieldKind::KVar(_hx_anonymous(array("get" => $get, "set" => $set, "type" => $type, "expr" => $expr)))));
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			}break;
			default:{
				$this->unexpected(hscript_Token::TId($id));
			}break;
			}
			unset($id);
		}
		$GLOBALS['%s']->pop();
	}
	public function incPos() {
		$GLOBALS['%s']->push("hscript.Parser::incPos");
		$__hx__spos = $GLOBALS['%s']->length;
		$GLOBALS['%s']->pop();
	}
	public function readChar() {
		$GLOBALS['%s']->push("hscript.Parser::readChar");
		$__hx__spos = $GLOBALS['%s']->length;
		try {
			{
				$tmp = $this->input->readByte();
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}catch(Exception $__hx__e) {
			$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
			$e = $_ex_;
			{
				$GLOBALS['%e'] = (new _hx_array(array()));
				while($GLOBALS['%s']->length >= $__hx__spos) {
					$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
				}
				$GLOBALS['%s']->push($GLOBALS['%e'][0]);
				{
					$GLOBALS['%s']->pop();
					return 0;
				}
			}
		}
		$GLOBALS['%s']->pop();
	}
	public function readString($until) {
		$GLOBALS['%s']->push("hscript.Parser::readString");
		$__hx__spos = $GLOBALS['%s']->length;
		$c = 0;
		$b = new haxe_io_BytesOutput();
		$esc = false;
		$old = $this->line;
		$s = $this->input;
		while(true) {
			try {
				$c = $s->readByte();
			}catch(Exception $__hx__e) {
				$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
				$e = $_ex_;
				{
					$GLOBALS['%e'] = (new _hx_array(array()));
					while($GLOBALS['%s']->length >= $__hx__spos) {
						$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
					}
					$GLOBALS['%s']->push($GLOBALS['%e'][0]);
					$this->line = $old;
					throw new HException(hscript_Error::$EUnterminatedString);
				}
			}
			if($esc) {
				$esc = false;
				switch($c) {
				case 34:case 39:case 92:{
					$b->writeByte($c);
				}break;
				case 47:{
					if($this->allowJSON) {
						$b->writeByte($c);
					} else {
						$this->invalidChar($c);
					}
				}break;
				case 110:{
					$b->writeByte(10);
				}break;
				case 114:{
					$b->writeByte(13);
				}break;
				case 116:{
					$b->writeByte(9);
				}break;
				case 117:{
					if(!$this->allowJSON) {
						$this->invalidChar($c);
					}
					$code = null;
					try {
						$code = $s->readString(4);
					}catch(Exception $__hx__e) {
						$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
						$e1 = $_ex_;
						{
							$GLOBALS['%e'] = (new _hx_array(array()));
							while($GLOBALS['%s']->length >= $__hx__spos) {
								$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
							}
							$GLOBALS['%s']->push($GLOBALS['%e'][0]);
							$this->line = $old;
							throw new HException(hscript_Error::$EUnterminatedString);
						}
					}
					$k = 0;
					{
						$_g = 0;
						while($_g < 4) {
							$_g = $_g + 1;
							$i = $_g - 1;
							$k = $k << 4;
							$char = _hx_char_code_at($code, $i);
							if($char === null) {
								$this->invalidChar($char);
							} else {
								switch($char) {
								case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:{
									$k = $k + ($char - 48);
								}break;
								case 65:case 66:case 67:case 68:case 69:case 70:{
									$k = $k + ($char - 55);
								}break;
								case 97:case 98:case 99:case 100:case 101:case 102:{
									$k = $k + ($char - 87);
								}break;
								default:{
									$this->invalidChar($char);
								}break;
								}
							}
							unset($i,$char);
						}
					}
					if($k <= 127) {
						$b->writeByte($k);
					} else {
						if($k <= 2047) {
							$b->writeByte(192 | $k >> 6);
							$b->writeByte(128 | $k & 63);
						} else {
							$b->writeByte(224 | $k >> 12);
							$b->writeByte(128 | $k >> 6 & 63);
							$b->writeByte(128 | $k & 63);
						}
					}
				}break;
				default:{
					$this->invalidChar($c);
				}break;
				}
			} else {
				if($c === 92) {
					$esc = true;
				} else {
					if($c === $until) {
						break;
					} else {
						if($c === 10) {
							$this->line++;
						}
						$b->writeByte($c);
					}
				}
			}
			unset($e);
		}
		{
			$tmp = $b->getBytes()->toString();
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function token() {
		$GLOBALS['%s']->push("hscript.Parser::token");
		$__hx__spos = $GLOBALS['%s']->length;
		if($this->tokens->head !== null) {
			$_this = $this->tokens;
			$k = $_this->head;
			if($k === null) {
				$GLOBALS['%s']->pop();
				return null;
			} else {
				$_this->head = $k->next;
				{
					$tmp = $k->elt;
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			}
		}
		$char = null;
		if($this->char < 0) {
			$char = $this->readChar();
		} else {
			$char = $this->char;
			$this->char = -1;
		}
		while(true) {
			switch($char) {
			case 0:{
				$tmp = hscript_Token::$TEof;
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			case 10:{
				$this->line++;
			}break;
			case 9:case 13:case 32:{
			}break;
			case 35:{
				$char = $this->readChar();
				if($this->idents[$char]) {
					$id = chr($char);
					while(true) {
						$char = $this->readChar();
						if(!$this->idents[$char]) {
							$this->char = $char;
							{
								$tmp = $this->preprocess($id);
								$GLOBALS['%s']->pop();
								return $tmp;
								unset($tmp);
							}
						}
						$id = _hx_string_or_null($id) . _hx_string_or_null(chr($char));
					}
				}
				$this->invalidChar($char);
			}break;
			case 34:case 39:{
				$tmp = hscript_Token::TConst(hscript_Const::CString($this->readString($char)));
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			case 40:{
				$tmp = hscript_Token::$TPOpen;
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			case 41:{
				$tmp = hscript_Token::$TPClose;
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			case 44:{
				$tmp = hscript_Token::$TComma;
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			case 46:{
				$char = $this->readChar();
				switch($char) {
				case 46:{
					$char = $this->readChar();
					if($char !== 46) {
						$this->invalidChar($char);
					}
					{
						$tmp = hscript_Token::TOp("...");
						$GLOBALS['%s']->pop();
						return $tmp;
					}
				}break;
				case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:{
					$n = $char - 48;
					$exp = 1;
					while(true) {
						$char = $this->readChar();
						$exp = $exp * 10;
						switch($char) {
						case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:{
							$n = $n * 10 + ($char - 48);
						}break;
						default:{
							$this->char = $char;
							{
								$tmp = hscript_Token::TConst(hscript_Const::CFloat($n / $exp));
								$GLOBALS['%s']->pop();
								return $tmp;
							}
						}break;
						}
					}
				}break;
				default:{
					$this->char = $char;
					{
						$tmp = hscript_Token::$TDot;
						$GLOBALS['%s']->pop();
						return $tmp;
					}
				}break;
				}
			}break;
			case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:{
				$n1 = ($char - 48) * 1.0;
				$exp1 = 0.;
				while(true) {
					$char = $this->readChar();
					$exp1 = $exp1 * 10;
					switch($char) {
					case 46:{
						if($exp1 > 0) {
							$tmp = null;
							if(_hx_equal($exp1, 10)) {
								$tmp = $this->readChar() === 46;
							} else {
								$tmp = false;
							}
							if($tmp) {
								{
									$_this1 = $this->tokens;
									$_this1->head = new haxe_ds_GenericCell(hscript_Token::TOp("..."), $_this1->head);
								}
								$i = Std::int($n1);
								$tmp1 = null;
								if(_hx_equal($i, $n1)) {
									$tmp1 = hscript_Const::CInt($i);
								} else {
									$tmp1 = hscript_Const::CFloat($n1);
								}
								{
									$tmp2 = hscript_Token::TConst($tmp1);
									$GLOBALS['%s']->pop();
									return $tmp2;
								}
							}
							$this->invalidChar($char);
						}
						$exp1 = 1.;
					}break;
					case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:{
						$n1 = $n1 * 10 + ($char - 48);
					}break;
					case 69:case 101:{
						$tk = $this->token();
						$pow = null;
						switch($tk->index) {
						case 1:{
							if(_hx_deref($tk)->params[0]->index === 0) {
								$e = _hx_deref(_hx_deref($tk)->params[0])->params[0];
								$pow = $e;
							} else {
								$_this2 = $this->tokens;
								$_this2->head = new haxe_ds_GenericCell($tk, $_this2->head);
							}
						}break;
						case 3:{
							if(_hx_deref($tk)->params[0] === "-") {
								$tk = $this->token();
								if($tk->index === 1) {
									if(_hx_deref($tk)->params[0]->index === 0) {
										$e1 = _hx_deref(_hx_deref($tk)->params[0])->params[0];
										$pow = -$e1;
									} else {
										$_this3 = $this->tokens;
										$_this3->head = new haxe_ds_GenericCell($tk, $_this3->head);
									}
								} else {
									$_this4 = $this->tokens;
									$_this4->head = new haxe_ds_GenericCell($tk, $_this4->head);
								}
							} else {
								$_this5 = $this->tokens;
								$_this5->head = new haxe_ds_GenericCell($tk, $_this5->head);
							}
						}break;
						default:{
							$_this6 = $this->tokens;
							$_this6->head = new haxe_ds_GenericCell($tk, $_this6->head);
						}break;
						}
						if($pow === null) {
							$this->invalidChar($char);
						}
						{
							$tmp = hscript_Token::TConst(hscript_Const::CFloat(Math::pow(10, $pow) / $exp1 * $n1 * 10));
							$GLOBALS['%s']->pop();
							return $tmp;
						}
					}break;
					case 120:{
						$tmp2 = null;
						if(!($n1 > 0)) {
							$tmp2 = $exp1 > 0;
						} else {
							$tmp2 = true;
						}
						if($tmp2) {
							$this->invalidChar($char);
						}
						$n2 = 0;
						while(true) {
							$char = $this->readChar();
							switch($char) {
							case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:{
								$n2 = ($n2 << 4) + $char - 48;
							}break;
							case 65:case 66:case 67:case 68:case 69:case 70:{
								$n2 = ($n2 << 4) + ($char - 55);
							}break;
							case 97:case 98:case 99:case 100:case 101:case 102:{
								$n2 = ($n2 << 4) + ($char - 87);
							}break;
							default:{
								$this->char = $char;
								{
									$tmp = hscript_Token::TConst(hscript_Const::CInt($n2));
									$GLOBALS['%s']->pop();
									return $tmp;
								}
							}break;
							}
						}
					}break;
					default:{
						$this->char = $char;
						$i1 = Std::int($n1);
						$tmp3 = null;
						if($exp1 > 0) {
							$tmp3 = hscript_Const::CFloat($n1 * 10 / $exp1);
						} else {
							if(_hx_equal($i1, $n1)) {
								$tmp3 = hscript_Const::CInt($i1);
							} else {
								$tmp3 = hscript_Const::CFloat($n1);
							}
						}
						{
							$tmp = hscript_Token::TConst($tmp3);
							$GLOBALS['%s']->pop();
							return $tmp;
						}
					}break;
					}
				}
			}break;
			case 58:{
				$tmp = hscript_Token::$TDoubleDot;
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			case 59:{
				$tmp = hscript_Token::$TSemicolon;
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			case 61:{
				$char = $this->readChar();
				if($char === 61) {
					$tmp = hscript_Token::TOp("==");
					$GLOBALS['%s']->pop();
					return $tmp;
				} else {
					if($char === 62) {
						$tmp = hscript_Token::TOp("=>");
						$GLOBALS['%s']->pop();
						return $tmp;
					}
				}
				$this->char = $char;
				{
					$tmp = hscript_Token::TOp("=");
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			}break;
			case 63:{
				$tmp = hscript_Token::$TQuestion;
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			case 64:{
				$char = $this->readChar();
				$tmp4 = null;
				if(!$this->idents[$char]) {
					$tmp4 = $char === 58;
				} else {
					$tmp4 = true;
				}
				if($tmp4) {
					$id1 = chr($char);
					while(true) {
						$char = $this->readChar();
						if(!$this->idents[$char]) {
							$this->char = $char;
							{
								$tmp = hscript_Token::TMeta($id1);
								$GLOBALS['%s']->pop();
								return $tmp;
								unset($tmp);
							}
						}
						$id1 = _hx_string_or_null($id1) . _hx_string_or_null(chr($char));
					}
				}
				$this->invalidChar($char);
			}break;
			case 91:{
				$tmp = hscript_Token::$TBkOpen;
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			case 93:{
				$tmp = hscript_Token::$TBkClose;
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			case 123:{
				$tmp = hscript_Token::$TBrOpen;
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			case 125:{
				$tmp = hscript_Token::$TBrClose;
				$GLOBALS['%s']->pop();
				return $tmp;
			}break;
			default:{
				if($this->ops[$char]) {
					$op = chr($char);
					$prev = -1;
					while(true) {
						$char = $this->readChar();
						$tmp5 = null;
						if(!(!$this->ops[$char])) {
							$tmp5 = $prev === 61;
						} else {
							$tmp5 = true;
						}
						if($tmp5) {
							if(_hx_char_code_at($op, 0) === 47) {
								$tmp = $this->tokenComment($op, $char);
								$GLOBALS['%s']->pop();
								return $tmp;
								unset($tmp);
							}
							$this->char = $char;
							{
								$tmp = hscript_Token::TOp($op);
								$GLOBALS['%s']->pop();
								return $tmp;
								unset($tmp);
							}
						}
						$prev = $char;
						$op = _hx_string_or_null($op) . _hx_string_or_null(chr($char));
						unset($tmp5);
					}
				}
				if($this->idents[$char]) {
					$id2 = chr($char);
					while(true) {
						$char = $this->readChar();
						if(!$this->idents[$char]) {
							$this->char = $char;
							{
								$tmp = hscript_Token::TId($id2);
								$GLOBALS['%s']->pop();
								return $tmp;
								unset($tmp);
							}
						}
						$id2 = _hx_string_or_null($id2) . _hx_string_or_null(chr($char));
					}
				}
				$this->invalidChar($char);
			}break;
			}
			$char = $this->readChar();
		}
		$GLOBALS['%s']->pop();
	}
	public function preprocValue($id) {
		$GLOBALS['%s']->push("hscript.Parser::preprocValue");
		$__hx__spos = $GLOBALS['%s']->length;
		{
			$tmp = $this->preprocesorValues->get($id);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public $preprocStack;
	public function parsePreproCond() {
		$GLOBALS['%s']->push("hscript.Parser::parsePreproCond");
		$__hx__spos = $GLOBALS['%s']->length;
		$tk = $this->token();
		switch($tk->index) {
		case 2:{
			$id = _hx_deref($tk)->params[0];
			{
				$tmp = hscript_Expr::EIdent($id);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 3:{
			if(_hx_deref($tk)->params[0] === "!") {
				$tmp = hscript_Expr::EUnop("!", true, $this->parsePreproCond());
				$GLOBALS['%s']->pop();
				return $tmp;
			} else {
				$tmp = $this->unexpected($tk);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 4:{
			{
				$_this = $this->tokens;
				$_this->head = new haxe_ds_GenericCell(hscript_Token::$TPOpen, $_this->head);
			}
			{
				$tmp = $this->parseExpr();
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		default:{
			$tmp = $this->unexpected($tk);
			$GLOBALS['%s']->pop();
			return $tmp;
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function evalPreproCond($e) {
		$GLOBALS['%s']->push("hscript.Parser::evalPreproCond");
		$__hx__spos = $GLOBALS['%s']->length;
		switch($e->index) {
		case 1:{
			$id = _hx_deref($e)->params[0];
			{
				$tmp = $this->preprocValue($id) !== null;
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 3:{
			$e1 = _hx_deref($e)->params[0];
			{
				$tmp = $this->evalPreproCond($e1);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 6:{
			switch(_hx_deref($e)->params[0]) {
			case "&&":{
				$e2 = _hx_deref($e)->params[2];
				$e11 = _hx_deref($e)->params[1];
				if($this->evalPreproCond($e11)) {
					$tmp = $this->evalPreproCond($e2);
					$GLOBALS['%s']->pop();
					return $tmp;
				} else {
					$GLOBALS['%s']->pop();
					return false;
				}
			}break;
			case "||":{
				$e21 = _hx_deref($e)->params[2];
				$e12 = _hx_deref($e)->params[1];
				if(!$this->evalPreproCond($e12)) {
					$tmp = $this->evalPreproCond($e21);
					$GLOBALS['%s']->pop();
					return $tmp;
				} else {
					$GLOBALS['%s']->pop();
					return true;
				}
			}break;
			default:{
				throw new HException(hscript_Error::EInvalidPreprocessor("Can't eval " . _hx_string_or_null(Type::enumConstructor($e))));
			}break;
			}
		}break;
		case 7:{
			if(_hx_deref($e)->params[0] === "!") {
				$e3 = _hx_deref($e)->params[2];
				{
					$tmp = !$this->evalPreproCond($e3);
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			} else {
				throw new HException(hscript_Error::EInvalidPreprocessor("Can't eval " . _hx_string_or_null(Type::enumConstructor($e))));
			}
		}break;
		default:{
			throw new HException(hscript_Error::EInvalidPreprocessor("Can't eval " . _hx_string_or_null(Type::enumConstructor($e))));
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function preprocess($id) {
		$GLOBALS['%s']->push("hscript.Parser::preprocess");
		$__hx__spos = $GLOBALS['%s']->length;
		switch($id) {
		case "else":case "elseif":{
			if($this->preprocStack->length > 0) {
				if(_hx_array_get($this->preprocStack, $this->preprocStack->length - 1)->r) {
					_hx_array_get($this->preprocStack, $this->preprocStack->length - 1)->r = false;
					$this->skipTokens();
					{
						$tmp = $this->token();
						$GLOBALS['%s']->pop();
						return $tmp;
					}
				} else {
					if($id === "else") {
						$this->preprocStack->pop();
						$this->preprocStack->push(_hx_anonymous(array("r" => true)));
						{
							$tmp = $this->token();
							$GLOBALS['%s']->pop();
							return $tmp;
						}
					} else {
						$this->preprocStack->pop();
						{
							$tmp = $this->preprocess("if");
							$GLOBALS['%s']->pop();
							return $tmp;
						}
					}
				}
			} else {
				$tmp = hscript_Token::TPrepro($id);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "end":{
			if($this->preprocStack->length > 0) {
				$this->preprocStack->pop();
				{
					$tmp = $this->token();
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			} else {
				$tmp = hscript_Token::TPrepro($id);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case "if":{
			$e = $this->parsePreproCond();
			if($this->evalPreproCond($e)) {
				$this->preprocStack->push(_hx_anonymous(array("r" => true)));
				{
					$tmp = $this->token();
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			}
			$this->preprocStack->push(_hx_anonymous(array("r" => false)));
			$this->skipTokens();
			{
				$tmp = $this->token();
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		default:{
			$tmp = hscript_Token::TPrepro($id);
			$GLOBALS['%s']->pop();
			return $tmp;
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function skipTokens() {
		$GLOBALS['%s']->push("hscript.Parser::skipTokens");
		$__hx__spos = $GLOBALS['%s']->length;
		$spos = $this->preprocStack->length - 1;
		$obj = $this->preprocStack[$spos];
		$pos = 0;
		while(true) {
			$tk = $this->token();
			if($tk === hscript_Token::$TEof) {
				throw new HException(hscript_Error::EInvalidPreprocessor("Unclosed"));
			}
			if(!_hx_equal($this->preprocStack[$spos], $obj)) {
				{
					$_this = $this->tokens;
					$_this->head = new haxe_ds_GenericCell($tk, $_this->head);
					unset($_this);
				}
				break;
			}
			unset($tk);
		}
		$GLOBALS['%s']->pop();
	}
	public function tokenComment($op, $char) {
		$GLOBALS['%s']->push("hscript.Parser::tokenComment");
		$__hx__spos = $GLOBALS['%s']->length;
		$c = _hx_char_code_at($op, 1);
		$s = $this->input;
		if($c === 47) {
			try {
				while(true) {
					$tmp = null;
					if($char !== 13) {
						$tmp = $char !== 10;
					} else {
						$tmp = false;
					}
					if(!$tmp) {
						break;
					}
					$char = $s->readByte();
					unset($tmp);
				}
				$this->char = $char;
			}catch(Exception $__hx__e) {
				$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
				$e = $_ex_;
				{
					$GLOBALS['%e'] = (new _hx_array(array()));
					while($GLOBALS['%s']->length >= $__hx__spos) {
						$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
					}
					$GLOBALS['%s']->push($GLOBALS['%e'][0]);
				}
			}
			{
				$tmp = $this->token();
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}
		if($c === 42) {
			$old = $this->line;
			if($op === "/**/") {
				$this->char = $char;
				{
					$tmp = $this->token();
					$GLOBALS['%s']->pop();
					return $tmp;
				}
			}
			try {
				while(true) {
					while($char !== 42) {
						if($char === 10) {
							$this->line++;
						}
						$char = $s->readByte();
					}
					$char = $s->readByte();
					if($char === 47) {
						break;
					}
				}
			}catch(Exception $__hx__e) {
				$_ex_ = ($__hx__e instanceof HException) && $__hx__e->getCode() == null ? $__hx__e->e : $__hx__e;
				$e1 = $_ex_;
				{
					$GLOBALS['%e'] = (new _hx_array(array()));
					while($GLOBALS['%s']->length >= $__hx__spos) {
						$GLOBALS['%e']->unshift($GLOBALS['%s']->pop());
					}
					$GLOBALS['%s']->push($GLOBALS['%e'][0]);
					$this->line = $old;
					throw new HException(hscript_Error::$EUnterminatedComment);
				}
			}
			{
				$tmp = $this->token();
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}
		$this->char = $char;
		{
			$tmp = hscript_Token::TOp($op);
			$GLOBALS['%s']->pop();
			return $tmp;
		}
		$GLOBALS['%s']->pop();
	}
	public function constString($c) {
		$GLOBALS['%s']->push("hscript.Parser::constString");
		$__hx__spos = $GLOBALS['%s']->length;
		switch($c->index) {
		case 0:{
			$v = _hx_deref($c)->params[0];
			{
				$tmp = Std::string($v);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 1:{
			$f = _hx_deref($c)->params[0];
			{
				$tmp = Std::string($f);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 2:{
			$s = _hx_deref($c)->params[0];
			{
				$GLOBALS['%s']->pop();
				return $s;
			}
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function tokenString($t) {
		$GLOBALS['%s']->push("hscript.Parser::tokenString");
		$__hx__spos = $GLOBALS['%s']->length;
		switch($t->index) {
		case 0:{
			$GLOBALS['%s']->pop();
			return "<eof>";
		}break;
		case 1:{
			$c = _hx_deref($t)->params[0];
			{
				$tmp = $this->constString($c);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 2:{
			$s = _hx_deref($t)->params[0];
			{
				$GLOBALS['%s']->pop();
				return $s;
			}
		}break;
		case 3:{
			$s1 = _hx_deref($t)->params[0];
			{
				$GLOBALS['%s']->pop();
				return $s1;
			}
		}break;
		case 4:{
			$GLOBALS['%s']->pop();
			return "(";
		}break;
		case 5:{
			$GLOBALS['%s']->pop();
			return ")";
		}break;
		case 6:{
			$GLOBALS['%s']->pop();
			return "{";
		}break;
		case 7:{
			$GLOBALS['%s']->pop();
			return "}";
		}break;
		case 8:{
			$GLOBALS['%s']->pop();
			return ".";
		}break;
		case 9:{
			$GLOBALS['%s']->pop();
			return ",";
		}break;
		case 10:{
			$GLOBALS['%s']->pop();
			return ";";
		}break;
		case 11:{
			$GLOBALS['%s']->pop();
			return "[";
		}break;
		case 12:{
			$GLOBALS['%s']->pop();
			return "]";
		}break;
		case 13:{
			$GLOBALS['%s']->pop();
			return "?";
		}break;
		case 14:{
			$GLOBALS['%s']->pop();
			return ":";
		}break;
		case 15:{
			$id = _hx_deref($t)->params[0];
			{
				$tmp = "@" . _hx_string_or_null($id);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		case 16:{
			$id1 = _hx_deref($t)->params[0];
			{
				$tmp = "#" . _hx_string_or_null($id1);
				$GLOBALS['%s']->pop();
				return $tmp;
			}
		}break;
		}
		$GLOBALS['%s']->pop();
	}
	public function __call($m, $a) {
		if(isset($this->$m) && is_callable($this->$m))
			return call_user_func_array($this->$m, $a);
		else if(isset($this->__dynamics[$m]) && is_callable($this->__dynamics[$m]))
			return call_user_func_array($this->__dynamics[$m], $a);
		else if('toString' == $m)
			return $this->__toString();
		else
			throw new HException('Unable to call <'.$m.'>');
	}
	static $p1 = 0;
	static $readPos = 0;
	static $tokenMin = 0;
	static $tokenMax = 0;
	function __toString() { return 'hscript.Parser'; }
}
